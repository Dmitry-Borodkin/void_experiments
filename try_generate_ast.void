{ v_import("mainline.void"); }
{ v_enable_mainline(); }

//---------------------------------------------------------------------
printf: (*const char, ...) ~> int;


//---------------------------------------------------------------------
//- unit                    +
//-
//- defn_list_unit          - generic list
//-   unit_defn_list        - generic list
//-
//- unit_fun_defn           - generic list
//- unit_var_defn           - generic list
//- unit_val_defn           - generic list
//- unit_ccif_list          - generic list
//- unit_struct_defn        - generic list
//- unit_spec_fun_defn      - generic list
//- unit_spec_fun_renm      - generic list
//- unit_union_defn         - generic list
//- unit_stmt_init          +
//- unit_stmt_term          +
//- unit_namespace_open     - generic list
//- unit_defn_close         - generic list
//- unit_defn_using         - generic list
//-
//- stmt_list               +
//-
//- stmt                    +
//- stmt_if_then_else       +
//- stmt_block              +
//- stmt_loop               +
//- stmt_defer              +
//- stmt_switch             +
//-   case_list             - generic list
//-   case_block            +
//- stmt_ccif_list          - generic list
//-
//- expr_list               +
//-
//- expr_call               +
//- expr_identifier         +
//- expr_integer            +
//- expr_string             +
//- expr_char               +
//- expr_struct             +
//- expr_union              +
//- expr_stmt               +
//-
//- br_item_list            - generic list
//- cc_message              - generic list
//- cc_do                   - generic list
//-
//- operator_unary          +
//- operator_binary         +
//- projection_payload      - generic list
//-
//- expr_compiled           !!!
//- expr_compile_spy        !!!
//---------------------------------------------------------------------



//---------------------------------------------------------------------
struct ctx_t
{
    gen_list: v_ast_stmt_list_t;

    max_var: int;
    cur_var: int;

    ret_var: v_quark_t;

    var_map: v_util_map_t;

};

//---------------------------------------------------------------------
(v_initialize(_)): (d: *ctx_t, n: size_t) ~> void
{
    for (i: &int := 0; i < n; ++i)
    {
        di = d[i];

        v_initialize(&di.gen_list);

        v_make_list_nil(&di.gen_list);

        di.max_var := -1;
        di.cur_var := -1;

        v_initialize(&di.var_map);

        v_make_map(&di.var_map);
    }
}

(v_terminate(_)): (d: *ctx_t, n: size_t) ~> void  =  derive;

//---------------------------------------------------------------------
(_.add_stmt()): (ctx: &ctx_t, stmt: *v_ast_stmt_t) ~> void
{
    list = &ctx.gen_list;

    v_list_append(list, list, stmt);
}

//---------------------------------------------------------------------
(_.push_var()): (ctx: &ctx_t) ~> int
{
    r = v_load(& ++ctx.cur_var);

    if (ctx.max_var < r)  ctx.max_var := r;

    v_return(r);
}

(_.pop_var()): (ctx: &ctx_t) ~> void
{
    --ctx.cur_var;
}

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_base",         q_ref, q("v_ast_base_ptr"));
    v_add_symbol("q_unit",         q_ref, q("v_ast_unit_ptr"));
    v_add_symbol("q_stmt_list",    q_ref, q("v_ast_stmt_list_ptr"));
    v_add_symbol("q_stmt",         q_ref, q("v_ast_stmt_ptr"));
    v_add_symbol("q_expr_list",    q_ref, q("v_ast_expr_list_ptr"));
    v_add_symbol("q_expr",         q_ref, q("v_ast_expr_ptr"));
    v_add_symbol("q_generic_list", q_ref, q("v_ast_generic_list_ptr"));

    v_add_symbol("q_cast",          q_ref, q("v_cast"));
    v_add_symbol("q_malloc",        q_ref, q("v_malloc"));
    v_add_symbol("q_free",          q_ref, q("v_free"));
    v_add_symbol("q_getelementptr", q_ref, q("v_getelementptr"));
    v_add_symbol("q_break",         q_ref, q("v_break"));
    v_add_symbol("q_reference",     q_ref, q("v_reference"));

    v_add_symbol("q_ast_make_unit", q_ref, q("v_ast_make_unit"));
    v_add_symbol("q_make_list_nil", q_ref, q("v_make_list_nil"));
    v_add_symbol("q_list_append",   q_ref, q("v_list_append"));

    v_add_symbol("q_quark_from_string", q_ref, q("v_quark_from_string"));

    v_add_symbol("q_ast_make_unit_stmt_init", q_ref, q("v_ast_make_unit_stmt_init"));
    v_add_symbol("q_ast_make_unit_stmt_term", q_ref, q("v_ast_make_unit_stmt_term"));

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));

    v_add_symbol("q_ast_make_stmt_q",            q_ref, q("v_ast_make_stmt_q"));
    v_add_symbol("q_ast_make_stmt_if_then_else", q_ref, q("v_ast_make_stmt_if_then_else"));
    v_add_symbol("q_ast_make_stmt_block",        q_ref, q("v_ast_make_stmt_block"));
    v_add_symbol("q_ast_make_stmt_loop",         q_ref, q("v_ast_make_stmt_loop"));
    v_add_symbol("q_ast_make_stmt_defer",        q_ref, q("v_ast_make_stmt_defer"));
    v_add_symbol("q_ast_make_stmt_switch",       q_ref, q("v_ast_make_stmt_switch"));
    v_add_symbol("q_ast_make_case_block",        q_ref, q("v_ast_make_case_block"));

    v_add_symbol("q_ast_make_expr_call",         q_ref, q("v_ast_make_expr_call"));
    v_add_symbol("q_ast_make_expr_identifier_q", q_ref, q("v_ast_make_expr_identifier_q"));
    v_add_symbol("q_ast_make_expr_integer",      q_ref, q("v_ast_make_expr_integer"));
    v_add_symbol("q_ast_make_expr_string_data",  q_ref, q("v_ast_make_expr_string_data"));
    v_add_symbol("q_ast_make_expr_char",         q_ref, q("v_ast_make_expr_char"));
    v_add_symbol("q_ast_make_expr_struct",       q_ref, q("v_ast_make_expr_struct"));
    v_add_symbol("q_ast_make_expr_union",        q_ref, q("v_ast_make_expr_union"));
    v_add_symbol("q_ast_make_expr_stmt",         q_ref, q("v_ast_make_expr_stmt"));

    v_add_symbol("q_ast_make_operator_unary",  q_ref, q("v_ast_make_operator_unary"));

    v_add_symbol("T_q", q_ref, q("T"));

    v_add_symbol("expr_identifier_q", q_ref, q("expr_identifier"));

    v_add_symbol("refcnt_ptr_q", q_ref, q("my.refcnt_ptr"));
}

//---------------------------------------------------------------------
(_.cast_var()): (ctx: &ctx_t, vn: int, qt: v_quark_t) ~> v_quark_t
{
    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "v.var.");

    v_std_string_append_number(&sstr, vn);

    qv = v_quark_from_string(v_std_string_get(&sstr));

    if (qt == q_base)   v_return(qv);

    v_std_string_append(&sstr, ".");
    v_std_string_append(&sstr, v_quark_to_string(qt));

    qr = v_quark_from_string(v_std_string_get(&sstr));

    vmap = &ctx.var_map;

    if (!v_map_find(vmap, (qr: intptr_t)))
    {
        a: &v_std_any_t := {};

        v_map_insert(vmap, vmap, (qr: intptr_t), &a);

        expr: &v_ast_expr_t[2] := {};

        v_ast_make_expr_identifier_q(expr+0, qv);
        v_ast_make_expr_identifier_q(expr+1, qt);

        stmt: &v_ast_stmt_t := {};

        v_ast_make_stmt_call(&stmt, qr, q_cast, expr, 2);
        ctx.add_stmt(&stmt);
    }

    v_return(qr);
}

//---------------------------------------------------------------------
(_.get_quark()): (ctx: &ctx_t, q: v_quark_t) ~> v_quark_t
{
    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "v.quark.");

    sq = v_quark_to_string(q);

    if (sq) v_std_string_append(&sstr, sq);
    else    v_std_string_append(&sstr, "()");

    qr = v_quark_from_string(v_std_string_get(&sstr));

    vmap = &ctx.var_map;

    if (!v_map_find(vmap, (qr: intptr_t)))
    {
        a: &v_std_any_t := {};

        v_map_insert(vmap, vmap, (qr: intptr_t), &a);

        expr: &v_ast_expr_t := {};
        stmt: &v_ast_stmt_t := {};

        if (sq)
        {
            v_ast_make_expr_string(&expr, sq);

            v_ast_make_stmt_call(&stmt, qr, q_quark_from_string, &expr, 1);
        }
        else
        {
            v_ast_make_expr_integer(&expr, 0);

            v_ast_make_stmt_q(&stmt, qr, &expr);
        }

        ctx.add_stmt(&stmt);
    }

    v_return(qr);
}


//---------------------------------------------------------------------
DEBUG_PRINT = false;

#if (DEBUG_PRINT)

indent: &int := 0;

pr_indent: () ~> void
{
    for (i: &int := 0; i < indent; ++i) printf("  ");
}

pr_ctx: () ~> void
{
    ctx: &ctx_t;

    printf("[%d, %d, %zd]\n", ctx.max_var, ctx.cur_var, v_list_get_size(&ctx.gen_list));
}

#endif

my_accept_visitor: (ast: *v_ast_base_t, vis: *voidc_visitor_t) ~> void
{
    q = v_ast_base_get_visitor_method_tag(ast);

#if (DEBUG_PRINT)

    pr_indent();  printf("%s(\n", v_quark_to_string(q));
//  pr_indent();  printf("%s( ", v_quark_to_string(q));  pr_ctx();

    indent++;

#endif

    if (q)  v_ast_accept_visitor(ast, vis);

#if (DEBUG_PRINT)

    indent--;

    pr_indent();  printf(")\n");
//  pr_indent();  printf(") "); pr_ctx();

#endif
}


//---------------------------------------------------------------------
//- unit
//---------------------------------------------------------------------
gen_unit: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    unit = (self: *v_ast_unit_t);

    list   = v_ast_unit_get_stmt_list(unit);
    line   = v_ast_unit_get_line(unit);
    column = v_ast_unit_get_column(unit);

    my_accept_visitor(list, vis);

    ctx = *(aux: *ctx_t);

    ql = ctx.cast_var(ctx.cur_var, q_stmt_list);
    qr = ctx.cast_var(ctx.cur_var, q_unit);

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, ql);

    v_ast_make_expr_integer(expr+2, line);
    v_ast_make_expr_integer(expr+3, column);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_unit, expr, 4);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- generic list
//---------------------------------------------------------------------
gen_generic_list: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    quark = v_ast_base_get_visitor_method_tag(self);

    stmt: &v_ast_stmt_t := {};

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_generic_list);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_ast_make_expr_identifier_q(expr+1, ctx.get_quark(quark));

    v_ast_make_stmt_call(&stmt, 0, q_make_list_nil, expr, 2);
    ctx.add_stmt(&stmt);

    v_copy(expr+1, expr+0);

    qi = ctx.cast_var(nvar+1, q_base);

    v_ast_make_expr_identifier_q(expr+2, qi);

    lst = (self: *v_ast_generic_list_t);

    for (N = v_list_get_size(lst), i: &int := 0; i < N; ++i)
    {
        item = v_list_get_item(lst, i);

        if (v_empty(item))
        {
            ctx.push_var();

            v_ast_make_stmt_call(&stmt, 0, q_terminate, expr+2, 1);
            ctx.add_stmt(&stmt);

            v_ast_make_stmt_call(&stmt, 0, q_initialize, expr+2, 1);
            ctx.add_stmt(&stmt);
        }
        else
        {
            my_accept_visitor(item, vis);
        }

        v_ast_make_stmt_call(&stmt, 0, q_list_append, expr, 3);
        ctx.add_stmt(&stmt);

        ctx.pop_var();
    }

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- unit_stmt_init
//---------------------------------------------------------------------
gen_unit_stmt_init: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    my_accept_visitor(&obj.body, vis);

    qb = ctx.cast_var(ctx.cur_var, q_stmt);
    qr = ctx.cast_var(ctx.cur_var, q_base);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qb);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_unit_stmt_init, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- unit_stmt_term
//---------------------------------------------------------------------
gen_unit_stmt_term: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    my_accept_visitor(&obj.body, vis);

    qb = ctx.cast_var(ctx.cur_var, q_stmt);
    qr = ctx.cast_var(ctx.cur_var, q_base);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qb);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_unit_stmt_term, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- stmt list
//---------------------------------------------------------------------
gen_stmt_list: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    stmt: &v_ast_stmt_t := {};

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_stmt_list);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_ast_make_stmt_call(&stmt, 0, q_make_list_nil, expr, 1);
    ctx.add_stmt(&stmt);

    v_copy(expr+1, expr+0);

    qi = ctx.cast_var(nvar+1, q_stmt);

    v_ast_make_expr_identifier_q(expr+2, qi);

    lst = (self: *v_ast_expr_list_t);

    for (N = v_list_get_size(lst), i: &int := 0; i < N; ++i)
    {
        item = v_list_get_item(lst, i);

        if (v_empty(item))
        {
            ctx.push_var();

            v_ast_make_stmt_call(&stmt, 0, q_terminate, expr+2, 1);
            ctx.add_stmt(&stmt);

            v_ast_make_stmt_call(&stmt, 0, q_initialize, expr+2, 1);
            ctx.add_stmt(&stmt);
        }
        else
        {
            my_accept_visitor(item, vis);
        }

        v_ast_make_stmt_call(&stmt, 0, q_list_append, expr, 3);
        ctx.add_stmt(&stmt);

        ctx.pop_var();
    }

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- stmt
//---------------------------------------------------------------------
gen_stmt: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    stm = (self: *v_ast_stmt_t);

    qname = v_ast_stmt_get_name_q(stm);
    sexpr = v_ast_stmt_get_expr(stm);

    expr: &v_ast_expr_t[3] := {};

    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);
    qe = ctx.cast_var(ctx.cur_var+1, q_expr);

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, ctx.get_quark(qname));
    v_ast_make_expr_identifier_q(expr+2, qe);

    stmt: &v_ast_stmt_t := {};

    if (v_empty(sexpr))
    {
        ctx.push_var();

        v_ast_make_stmt_call(&stmt, 0, q_terminate, expr+2, 1);
        ctx.add_stmt(&stmt);

        v_ast_make_stmt_call(&stmt, 0, q_initialize, expr+2, 1);
        ctx.add_stmt(&stmt);
    }
    else
    {
        my_accept_visitor(sexpr, vis);
    }

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_q, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- stmt if_then_else
//---------------------------------------------------------------------
gen_stmt_if_then_else: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_stmt_if_then_else_t);

    cond = &obj[0];
    then = &obj[1];
    else = &obj[2];

    qcond = ctx.cast_var(ctx.cur_var+1, q_expr);
    qthen = ctx.cast_var(ctx.cur_var+2, q_stmt);
    qelse = ctx.cast_var(ctx.cur_var+3, q_stmt);

    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qcond);
    v_ast_make_expr_identifier_q(expr+2, qthen);
    v_ast_make_expr_identifier_q(expr+3, qelse);

    my_accept_visitor(cond, vis);
    my_accept_visitor(then, vis);

    stmt: &v_ast_stmt_t := {};

    if (v_empty(else))
    {
        ctx.push_var();

        v_ast_make_stmt_call(&stmt, 0, q_terminate, expr+3, 1);
        ctx.add_stmt(&stmt);

        v_ast_make_stmt_call(&stmt, 0, q_initialize, expr+3, 1);
        ctx.add_stmt(&stmt);
    }
    else
    {
        my_accept_visitor(else, vis);
    }

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_if_then_else, expr, 4);
    ctx.add_stmt(&stmt);

    ctx.pop_var();
    ctx.pop_var();

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- stmt block
//---------------------------------------------------------------------
gen_stmt_block: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_stmt_block_t);

    body = &obj[0];
    flag = obj[1];

    qb = ctx.cast_var(ctx.cur_var+1, q_stmt_list);
    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qb);

    v_ast_make_expr_integer(expr+2, flag);

    my_accept_visitor(body, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_block, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- stmt loop
//---------------------------------------------------------------------
gen_stmt_loop: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_stmt_loop_t);

    body = &obj[0];

    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qr);

    my_accept_visitor(body, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_loop, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- stmt defer
//---------------------------------------------------------------------
gen_stmt_defer: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_stmt_defer_t);

    body = &obj[0];

    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qr);

    my_accept_visitor(body, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_defer, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- stmt switch
//---------------------------------------------------------------------
gen_stmt_switch: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_stmt_switch_t);

    arg = &obj[0];
    lst = &obj[1];

    qarg = ctx.cast_var(ctx.cur_var+1, q_expr);
    qlst = ctx.cast_var(ctx.cur_var+2, q_generic_list);

    qr = ctx.cast_var(ctx.cur_var+1, q_stmt);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qarg);
    v_ast_make_expr_identifier_q(expr+2, qlst);

    my_accept_visitor(arg, vis);
    my_accept_visitor(lst, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_stmt_switch, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.pop_var();

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- case block
//---------------------------------------------------------------------
gen_case_block: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_case_block_t);

    arg = &obj[0];
    lst = &obj[1];

    qarg = ctx.cast_var(ctx.cur_var+1, q_expr_list);
    qlst = ctx.cast_var(ctx.cur_var+2, q_stmt_list);

    qr = ctx.cast_var(ctx.cur_var+1, q_base);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qarg);
    v_ast_make_expr_identifier_q(expr+2, qlst);

    my_accept_visitor(arg, vis);
    my_accept_visitor(lst, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_case_block, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.pop_var();

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- expr list
//---------------------------------------------------------------------
gen_expr_list: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    stmt: &v_ast_stmt_t := {};

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_expr_list);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_ast_make_stmt_call(&stmt, 0, q_make_list_nil, expr, 1);
    ctx.add_stmt(&stmt);

    v_copy(expr+1, expr+0);

    qi = ctx.cast_var(nvar+1, q_expr);

    v_ast_make_expr_identifier_q(expr+2, qi);

    lst = (self: *v_ast_stmt_list_t);

    for (N = v_list_get_size(lst), i: &int := 0; i < N; ++i)
    {
        item = v_list_get_item(lst, i);

        if (v_empty(item))
        {
            ctx.push_var();

            v_ast_make_stmt_call(&stmt, 0, q_terminate, expr+2, 1);
            ctx.add_stmt(&stmt);

            v_ast_make_stmt_call(&stmt, 0, q_initialize, expr+2, 1);
            ctx.add_stmt(&stmt);
        }
        else
        {
            my_accept_visitor(item, vis);
        }

        v_ast_make_stmt_call(&stmt, 0, q_list_append, expr, 3);
        ctx.add_stmt(&stmt);

        ctx.pop_var();
    }

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- expr call
//---------------------------------------------------------------------
gen_expr_call: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    call = (self: *v_ast_expr_t);

    fun = v_ast_expr_call_get_fun_expr(call);
    lst = v_ast_expr_call_get_arg_list(call);

    qfun = ctx.cast_var(ctx.cur_var+1, q_expr);
    qlst = ctx.cast_var(ctx.cur_var+2, q_expr_list);

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qfun);
    v_ast_make_expr_identifier_q(expr+2, qlst);

    my_accept_visitor(fun, vis);
    my_accept_visitor(lst, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_call, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.pop_var();

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr identifier
//---------------------------------------------------------------------
gen_expr_identifier: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    eid = (self: *v_ast_expr_t);

    qn = v_ast_expr_identifier_get_name_q(eid);

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_expr);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, ctx.get_quark(qn));

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_identifier_q, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr integer
//---------------------------------------------------------------------
gen_expr_integer: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    enum = (self: *v_ast_expr_t);

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_expr);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_copy(expr+1, enum);           //- !?!

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_integer, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr string
//---------------------------------------------------------------------
gen_expr_string: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    estr = (self: *v_ast_expr_t);

    len: &size_t := v_undef();

    v_ast_expr_string_get_string_data(estr, &len);

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_expr);

    expr: &v_ast_expr_t[3] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_copy(expr+1, estr);           //- !?!

    v_ast_make_expr_integer(expr+2, len);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_string_data, expr, 3);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr char
//---------------------------------------------------------------------
gen_expr_char: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    echar = (self: *v_ast_expr_t);

    nvar = ctx.push_var();

    qr = ctx.cast_var(nvar, q_expr);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_copy(expr+1, echar);          //- !?!

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_char, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr struct
//---------------------------------------------------------------------
gen_expr_struct: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_expr_struct_t);

    name = &obj[0];
    body = &obj[1];

    packed = obj[2];
    export = obj[3];

    qname = ctx.cast_var(ctx.cur_var+1, q_expr);
    qbody = ctx.cast_var(ctx.cur_var+2, q_stmt_list);

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[5] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qname);
    v_ast_make_expr_identifier_q(expr+2, qbody);

    my_accept_visitor(name, vis);
    my_accept_visitor(body, vis);

    v_ast_make_expr_integer(expr+3, packed);
    v_ast_make_expr_integer(expr+4, export);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_struct, expr, 5);
    ctx.add_stmt(&stmt);

    ctx.pop_var();

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr union
//---------------------------------------------------------------------
gen_expr_union: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_expr_union_t);

    qname = ctx.cast_var(ctx.cur_var+1, q_expr);
    qbody = ctx.cast_var(ctx.cur_var+2, q_stmt_list);

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qname);
    v_ast_make_expr_identifier_q(expr+2, qbody);

    my_accept_visitor(&obj.name, vis);
    my_accept_visitor(&obj.body, vis);

    v_ast_make_expr_integer(expr+3, obj.export);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_union, expr, 4);
    ctx.add_stmt(&stmt);

    ctx.pop_var();

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- expr stmt
//---------------------------------------------------------------------
gen_expr_stmt: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_expr_stmt_t);

    qstmt = ctx.cast_var(ctx.cur_var+1, q_stmt);

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);
    v_ast_make_expr_identifier_q(expr+1, qstmt);

    my_accept_visitor(&obj.stmt, vis);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_expr_stmt, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}


//---------------------------------------------------------------------
//- operator unary
//---------------------------------------------------------------------
gen_operator_unary: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_operator_unary_t);

    quark =  obj[0];
    prio  =  obj[1];
    pay   = &obj[2];

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    if (v_empty(pay))
    {
        ctx.push_var();

        sstr: &v_std_string_t := {};

        v_std_string_set(&sstr, "v_");

        v_std_string_append(&sstr, v_quark_to_string(quark)+2);     //- Skip "v."

        v_ast_make_expr_identifier(expr+1, v_std_string_get(&sstr));

        stmt: &v_ast_stmt_t := {};

        v_ast_make_stmt_call(&stmt, 0, q_copy, expr, 2);
        ctx.add_stmt(&stmt);

        ctx.ret_var := qr;

        v_return();
    }

    qpay = ctx.cast_var(ctx.cur_var+1, q_generic_list);

    my_accept_visitor(pay, vis);

    v_ast_make_expr_identifier_q(expr+1, ctx.get_quark(quark));

    v_ast_make_expr_integer(expr+2, prio);

    v_ast_make_expr_identifier_q(expr+3, qpay);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_ast_make_operator_unary, expr, 4);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}

//---------------------------------------------------------------------
//- operator binary
//---------------------------------------------------------------------
gen_operator_binary: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *ctx_t);

    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_operator_binary_t);

    quark =  obj[0];
    prio  =  obj[1];
    assoc =  obj[2];
    pay   = &obj[3];

    qr = ctx.cast_var(ctx.cur_var+1, q_expr);

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_identifier_q(expr+0, qr);

    v_assert(v_empty(pay));

    ctx.push_var();

    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "v_");

    v_std_string_append(&sstr, v_quark_to_string(quark)+2);     //- Skip "v."

    v_ast_make_expr_identifier(expr+1, v_std_string_get(&sstr));

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt_call(&stmt, 0, q_copy, expr, 2);
    ctx.add_stmt(&stmt);

    ctx.ret_var := qr;
}


//=====================================================================
gen_visitor: &voidc_visitor_t := {};

ctx: &ctx_t := 0;

//---------------------------------------------------------------------
mk_quote_ast_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    id = v_std_any_get_pointer(v_std_string_t, any);

    a: &v_std_any_t := {};

    v_peg_parse(&a, v_quark_from_string(v_std_string_get(id)));

    ast = v_ast_std_any_get_base(&a);

    v_assert(ast);

    v_initialize(&ctx);

    my_accept_visitor(ast, &gen_visitor);

    v_assert(ctx.cur_var == 0 <= ctx.max_var);

    slst: &v_ast_stmt_list_t[2] := {};

    v_make_list_nil(slst+0);

    expr: &v_ast_expr_t[2] := {};

    v_ast_make_expr_identifier(expr+0, "v_ast_base_t");

    n = ctx.max_var + 1;

    v_ast_make_expr_integer(expr+1, n);

    stmt: &v_ast_stmt_t := {};

    qv0 = ctx.cast_var(0, q_base);

    v_ast_make_stmt_call(&stmt, qv0, q_malloc, expr, 2);
    v_list_append(slst+0, slst+0, &stmt);

    v_ast_make_expr_identifier_q(expr+0, qv0);

    v_ast_make_stmt_call(&stmt, 0, q_initialize, expr, 2);
    v_list_append(slst+0, slst+0, &stmt);

    v_ast_make_stmt_call(&stmt, 0, q_terminate, expr, 2);
    v_make_list(slst+1, &stmt);

    v_ast_make_stmt_call(&stmt, 0, q_free, expr, 1);
    v_list_append(slst+1, slst+1, &stmt);

    v_ast_make_stmt_block(&stmt, slst+1, false);
    v_ast_make_stmt_defer(&stmt, &stmt);
    v_list_append(slst+0, slst+0, &stmt);

    for (i: &int := 1; i < n; ++i)
    {
        v_ast_make_expr_integer(expr+1, i);

        v_ast_make_stmt_call(&stmt, ctx.cast_var(i, q_base), q_getelementptr, expr, 2);
        v_list_append(slst+0, slst+0, &stmt);
    }

    for (N = v_list_get_size(&ctx.gen_list), i: &int := 0; i < N; ++i)
    {
        item = v_list_get_item(&ctx.gen_list, i);

        v_list_append(slst+0, slst+0, item);
    }

    v_ast_make_expr_identifier_q(expr+0, ctx.ret_var);

    elst: &v_ast_expr_list_t := {};

    v_make_list(&elst, expr+0);

    v_ast_make_expr_identifier_q(expr+0, q_reference);

    v_ast_make_expr_call(expr+0, expr+0, &elst);

    v_ast_make_stmt_call(&stmt, 0, q_break, expr, 1);
    v_list_append(slst+0, slst+0, &stmt);

    v_ast_make_stmt_block(&stmt, slst+0, true);

    v_ast_make_expr_stmt(expr+0, &stmt);

    v_terminate(&ctx);

    v_std_any_set_pointer(ret, expr+0);
}

//---------------------------------------------------------------------
{
    vis = &gen_visitor;

    voidc_make_visitor(vis);

    q = v_quark_from_string;

    voidc_visitor_set_method(vis, vis, q("unit"),                gen_unit,              &ctx);
    voidc_visitor_set_method(vis, vis, q("defn_list_unit"),      gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_defn_list"),      gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_fun_defn"),       gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_var_defn"),       gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_val_defn"),       gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_ccif_list"),      gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_struct_defn"),    gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_spec_fun_defn"),  gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_spec_fun_renm"),  gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_union_defn"),     gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_stmt_init"),      gen_unit_stmt_init,    &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_stmt_term"),      gen_unit_stmt_term,    &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_namespace_open"), gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_defn_close"),     gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("unit_defn_using"),     gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_list"),           gen_stmt_list,         &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt"),                gen_stmt,              &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_if_then_else"),   gen_stmt_if_then_else, &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_block"),          gen_stmt_block,        &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_loop"),           gen_stmt_loop,         &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_defer"),          gen_stmt_defer,        &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_switch"),         gen_stmt_switch,       &ctx);
    voidc_visitor_set_method(vis, vis, q("case_list"),           gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("case_block"),          gen_case_block,        &ctx);
    voidc_visitor_set_method(vis, vis, q("stmt_ccif_list"),      gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_list"),           gen_expr_list,         &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_call"),           gen_expr_call,         &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_identifier"),     gen_expr_identifier,   &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_integer"),        gen_expr_integer,      &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_string"),         gen_expr_string,       &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_char"),           gen_expr_char,         &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_struct"),         gen_expr_struct,       &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_union"),          gen_expr_union,        &ctx);
    voidc_visitor_set_method(vis, vis, q("expr_stmt"),           gen_expr_stmt,         &ctx);
    voidc_visitor_set_method(vis, vis, q("br_item_list"),        gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("cc_message"),          gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("cc_do"),               gen_generic_list,      &ctx);
    voidc_visitor_set_method(vis, vis, q("operator_unary"),      gen_operator_unary,    &ctx);
    voidc_visitor_set_method(vis, vis, q("operator_binary"),     gen_operator_binary,   &ctx);
    voidc_visitor_set_method(vis, vis, q("projection_payload"),  gen_generic_list,      &ctx);

    gr0: &v_peg_grammar_t := {};        gr0 = &gr0;

    v_peg_get_grammar(gr0);

    grammar gr0
    {
    actions:
        mk_quote_ast = mk_quote_ast_grammar_action;

    parsers:
        prim =+ '{' <'\'' i:identifier (![\n\r\t\'] .)* '\''> _ e:{ mk_quote_ast(i) } _ $1 '}' { e };
    }

    v_peg_set_grammar(gr0);
}


//=====================================================================
namespace my {


//---------------------------------------------------------------------
refcnt_ptr = v_object_intrinsic("my.refcnt_ptr");

//private
refcnt_ptr_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    arg = v_type_generic_type_arg(elt);

    typ = v_generic_type(refcnt_ptr_q, &arg, 1);

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//private
refcnt_ptr_obtain_llvm_type: (*void, typ: *v_type_t) ~> LLVMTypeRef
{
    rt = v_pointer_type(v_void_type(), 0);          //- Sic !?!

    rt_ = v_type_get_llvm_type(rt);

    v_type_set_cached_llvm_type(typ, rt_);

    v_return(rt_);
}


//---------------------------------------------------------------------
refcnt_ptr_ns = v_object_intrinsic("refcnt_ptr.namespace");

//---------------------------------------------------------------------
refcnt_ptr_ns_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "refcnt_ptr_ns-");

    voidc_internal_std_string_append_type(&sstr, elt);

    ns_name = v_quark_from_string(v_std_string_get(&sstr));

    ns = (aux: *v_namespace_t);

    if (a = v_map_find(&ns->map, (ns_name: intptr_t)))
    {
        q = v_std_any_get_value(v_quark_t, a);

        t: &*v_type_t    := v_undef();
        v: &LLVMValueRef := v_undef();

        v_find_constant_q(q, &t, &v);

        v_set_result_type(t);
        v_set_result_value(v);
    }
    else
    {
        v_set_result_type(v_void_type());                   //- Sic !?!
        v_set_result_value((ns_name: LLVMValueRef));        //- Sic !?!
    }
}

{   v_add_intrinsic("refcnt_ptr.namespace", refcnt_ptr_ns_intrinsic, v_find_constant_value("my")); }


//{ v_debug_print_module(1); }
//---------------------------------------------------------------------
private
instantiate_ast: &v_ast_generic_list_t :=           //- T - type parameter ...
{'unit_defn_list'

namespace my {

inlinehint
(v_initialize(_)): (sp: *refcnt_ptr(T), N: size_t) ~> void
{
    .memset: (s: *void, c: int, n: size_t) ~> *void;

    .memset(sp, 0, N*my.refcnt_ptr(T).size);
}


namespace refcnt_ptr_ns(T) {

private
struct data_t
{
    count: size_t;

    data: T;
};

inlinehint
(v_initialize(_)): (*data_t, size_t) ~> void  =  derive;

inlinehint
(v_terminate(_)): (*data_t, size_t) ~> void  =  derive;

private
alwaysinline
get_data: (p: *T) ~> &data_t
{
    v_assert(p);

    r = *((p: *char) - (&(0: *data_t)->data : intptr_t) : *data_t);

    v_return(r);
}

inlinehint
create: () ~> refcnt_ptr(T)
{
    ret = v_get_return_value();

    dp = new data_t {{1}};

    *(&ret : **T) := &dp->data;
}

private
inlinehint
inc: (p: *T) ~> void
{
    d = get_data(p);

    ++d.count;
}

private
inlinehint
dec: (p: *T) ~> void
{
    d = get_data(p);

    if (--d.count == 0) delete &d;
}

}   //- namespace refcnt_ptr_ns(T)


inlinehint
(v_terminate(_)): (sp: *refcnt_ptr(T), N: size_t) ~> void
{
    for (i: &int := 0; i < N; ++i)
    {
        pi = *(sp+i : **T);

        if (pi) refcnt_ptr_ns(T).dec(pi);
    }
}

inlinehint
(v_copy(_)): (dst: *refcnt_ptr(T), src: *const refcnt_ptr(T), N: size_t) ~> void
{
    for (i: &int := 0; i < N; ++i)
    {
        dpi = *(dst+i : **T);
        spi = *(src+i : **T);

        if (dpi)  refcnt_ptr_ns(T).dec(dpi);
        if (spi)  refcnt_ptr_ns(T).inc(spi);

        dpi := spi;
    }
}

inlinehint
(v_move(_)): (dst: *refcnt_ptr(T), src: *refcnt_ptr(T), N: size_t) ~> void
{
    for (i: &int := 0; i < N; ++i)
    {
        dpi = *(dst+i : **T);
        spi = *(src+i : **T);

        if (dpi)  refcnt_ptr_ns(T).dec(dpi);

        dpi := spi;
        spi := 0;
    }
}


alwaysinline
(_.get()): (sp: &const refcnt_ptr(T)) ~> *T  =  *(&sp: **T);

alwaysinline
(_.get()): (sp: refcnt_ptr(T)) ~> *T  =  *(&sp: **T);


alwaysinline
(*_): (sp: &const refcnt_ptr(T)) ~> &T  =  *sp.get();

alwaysinline
(*_): (sp: refcnt_ptr(T)) ~> &T  =  *sp.get();

alwaysinline
(_->): (sp: &const refcnt_ptr(T)) ~> *T  =  sp.get();

alwaysinline
(_->): (sp: refcnt_ptr(T)) ~> *T  =  sp.get();


alwaysinline
(_:=_): (dst: &refcnt_ptr(T), src: refcnt_ptr(T)) ~> &refcnt_ptr(T)
{
    v_copy(&dst, &src);

    v_return(dst);
}


alwaysinline
(_.use_count): (sp: &const refcnt_ptr(T)) ~> size_t  =  refcnt_ptr_ns(T).get_data(sp.get()).count;

alwaysinline
(_.use_count): (sp: refcnt_ptr(T)) ~> size_t  =  refcnt_ptr_ns(T).get_data(sp.get()).count;


}   //- namespace my

'unit_defn_list'};

//---------------------------------------------------------------------
private
my_compile_expr_identifier_ctx_t = struct
{
    fun: *((*void, *voidc_visitor_t, *v_ast_base_t) ~> void);
    aux: *void;

    par: *v_ast_expr_t;
};

private
my_compile_expr_identifier: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_compile_expr_identifier start\n");
//defer printf("my_compile_expr_identifier stop\n");

    ctx = *(aux: *my_compile_expr_identifier_ctx_t);

    qname = v_ast_expr_identifier_get_name_q((self: *v_ast_expr_t));

    if (qname == T_q)
    {
        v_ast_accept_visitor(ctx.par, vis);

        v_return();
    }

    ctx.fun(ctx.aux, vis, self);
}

//---------------------------------------------------------------------
//export
instantiate_refcnt_ptr = v_object_intrinsic("my.instantiate_refcnt_ptr");

//---------------------------------------------------------------------
//private
instantiate_refcnt_ptr_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("instantiate_refcnt_ptr_intrinsic start\n");
//defer printf("instantiate_refcnt_ptr_intrinsic stop\n");

    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    //-------------------------------------------------------------
    //- T - type parameter ...
    //-------------------------------------------------------------

    par: &v_ast_expr_t := {};

    v_ast_make_expr_compiled(&par, v_static_type_t, (elt: LLVMValueRef));

    ctx: &my_compile_expr_identifier_ctx_t := v_undef();

    q = expr_identifier_q;

    ctx.fun := voidc_visitor_get_method(vis, q, &ctx.aux);

    ctx.par := &par;

    //-------------------------------------------------------------
    v_assert(vis == v_get_compiler());

    saved_vis: &voidc_visitor_t := {};

    v_copy(&saved_vis, vis);

    voidc_visitor_set_method(vis, vis, q, my_compile_expr_identifier, &ctx);

    n = v_list_get_size(&instantiate_ast);

    for (i: &int := 0; i < n; ++i)
    {
        item = v_list_get_item(&instantiate_ast, i);

        v_ast_accept_visitor(item, vis);
    }

    v_copy(vis, &saved_vis);
}


//---------------------------------------------------------------------
private
make_refcnt_ast: &v_ast_expr_t  :=  {'expr'  .my.refcnt_ptr_ns(T).create()  'expr'};

//---------------------------------------------------------------------
//export
make_refcnt = v_object_intrinsic("my.make_refcnt");

//---------------------------------------------------------------------
//private
make_refcnt_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("make_refcnt_intrinsic start\n");
//defer printf("make_refcnt_intrinsic stop\n");

    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    //-------------------------------------------------------------
    //- T - type parameter ...
    //-------------------------------------------------------------

    par: &v_ast_expr_t := {};

    v_ast_make_expr_compiled(&par, v_static_type_t, (elt: LLVMValueRef));

    ctx: &my_compile_expr_identifier_ctx_t := v_undef();

    q = expr_identifier_q;

    ctx.fun := voidc_visitor_get_method(vis, q, &ctx.aux);

    ctx.par := &par;

    //-------------------------------------------------------------
    v_assert(vis == v_get_compiler());

    saved_vis: &voidc_visitor_t := {};

    v_copy(&saved_vis, vis);

    voidc_visitor_set_method(vis, vis, q, my_compile_expr_identifier, &ctx);

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_ast_accept_visitor(&make_refcnt_ast, vis);

    v_copy(vis, &saved_vis);
}


//---------------------------------------------------------------------
//export
enable_refcnt_ptr: () ~> void
{
    v_add_intrinsic("my.refcnt_ptr", refcnt_ptr_intrinsic, 0);

    v_type_generic_set_obtain_llvm_type_hook(refcnt_ptr_q, refcnt_ptr_obtain_llvm_type, 0);

    v_add_intrinsic("my.instantiate_refcnt_ptr", instantiate_refcnt_ptr_intrinsic, 0);

    v_add_intrinsic("my.make_refcnt", make_refcnt_intrinsic, 0);
}


//=====================================================================
}   //- namespace my


//---------------------------------------------------------------------
{   my.enable_refcnt_ptr(); }       //- WTF !?!?!?!?!?!?!



//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
#do
(
    my.instantiate_refcnt_ptr(int),
)


some = my.make_refcnt(int);

{   *some := 777;
}

{   printf("some: %d\n", *some); }


{   foo: &my.refcnt_ptr(int)[3] := { some, some, some };

    printf("some.use_count: %zd\n", some.use_count);
}

{   printf("some.use_count: %zd\n", some.use_count);
}

{   foo: &my.refcnt_ptr(int) := {};

    printf("foo.use_count: %zd\n", foo.use_count);
}



