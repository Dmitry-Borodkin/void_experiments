{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");
    v_import("level-03");

    v_import("llvm-c/Core.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();
    v_enable_level_03();
}


//=====================================================================
v_internal_fake_utility_intrinsic: (*voidc_visitor_t, aux: *void, *v_ast_base_t,
                                    *v_type_t, LLVMValueRef) -> void
{
    q = v_quark_to_string((aux: v_quark_t));

    printf("v_internal_fake_utility_intrinsic: %s\n", q);

    exit: (int) -> void;

    exit(-1);       //- Sic!
}

{   sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    qnames: &(*const char)[] :=
    {
        "v_initialize",
        "v_terminate",
        "v_copy",
        0
    };

    for (name: &**const char := &qnames[0]; *name; ++name)
    {
        v_std_string_set(sstr, "v.internal.fake_utility.");

        v_std_string_append(sstr, *name);

        q_fake = v_quark_from_string(v_std_string_get(sstr));
        q_name = v_quark_from_string(*name);

        v_add_intrinsic_q(q_fake, v_internal_fake_utility_intrinsic, (q_name: *void));
    }

    //-----------------------------------------------------------------
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool;

//---------------------------------------------------------------------
v_type_check_special: (t: *v_type_t, q: v_quark_t) -> void
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
    case v_type_kind_struct:
        v_break();

    default:
        v_return();
    }

    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    v_std_string_set(sstr, v_quark_to_string(q));

    v_std_string_append(sstr, ".checked");

    q_checked = v_quark_from_string(v_std_string_get(sstr));

    if (v_type_get_property(t, q_checked))  v_return();

    block
    {
        if (v_type_is_array(t))
        {
            v_type_check_special(v_type_array_get_element_type(t), q);
            v_break();
        }

        if (v_type_is_struct(t))
        {
            if (v_type_get_property(t, q))  v_break();

            flag: &bool := false;

            count = v_type_struct_get_element_count(t);
            types = v_type_struct_get_element_types(t);

            for (i: &int := 0; i < count; ++i)
            {
                flag |= v_type_is_special(types[i], q);

                if (flag)   v_break();
            }

            if (flag)
            {
                v_std_string_set(sstr, "v.internal.fake_utility.");

                v_std_string_append(sstr, v_quark_to_string(q));

                q_fake = v_quark_from_string(v_std_string_get(sstr));

                v_util_function_dict_set(t, q, q_fake);
            }

            v_break();
        }

        //- ?!? ...
    }

    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, true);

    v_type_set_property(t, q_checked, any);
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
        v_return(v_type_is_special(v_type_array_get_element_type(t), q));

    case v_type_kind_struct:
        v_break();

    default:
        v_return(false);        //- Sic!!!
    }

    v_type_check_special(t, q);

    v_return(v_type_get_property(t, q) != 0);
}


//=====================================================================
struct compile_stmt_hook_t
{
    fun: *((*voidc_visitor_t, *void, *v_ast_base_t) -> void);
    aux: *void;
};

//---------------------------------------------------------------------
UNNAMED_VTAG = ( 0: LLVMValueRef);
NAMED_VTAG   = (-1: LLVMValueRef);

//---------------------------------------------------------------------
my_compile_stmt: (vis: *voidc_visitor_t, void_aux: *void, self: *v_ast_base_t) -> void
{
    expr = v_ast_stmt_get_expr((self: *v_ast_stmt_t));
    if (v_empty(expr))  v_return();                             //- Sic!

    name = v_ast_stmt_get_name((self: *v_ast_stmt_t));

    if (name  &&  name[0])  v_set_result_value(NAMED_VTAG);     //- Sic!
    else                    v_set_result_value(UNNAMED_VTAG);   //- Sic!

    aux = *(void_aux: *compile_stmt_hook_t);

    aux.fun(vis, aux.aux, self);
}

//---------------------------------------------------------------------
my_stmt_hook: &compile_stmt_hook_t := v_undef();

//---------------------------------------------------------------------
{   vis = voidc_compiler;

    stmt_q = v_quark_from_string("stmt");

    my_stmt_hook.fun := voidc_visitor_get_void_method(vis, stmt_q, &my_stmt_hook.aux);

    voidc_visitor_set_void_method(vis, vis, stmt_q, my_compile_stmt, &my_stmt_hook);
}


//=====================================================================
v_type_function_obtain_llvm_type_hook: (*void, ft: *v_type_t) -> LLVMTypeRef
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    n: &unsigned := par_count;

    rt = v_type_function_get_return_type(ft);

    rt_initializable = v_type_is_special(rt, q_initialize);

    if (rt_initializable) ++n;

    par = v_malloc(LLVMTypeRef, n);
    defer v_free(par);

    llvm_ctx = v_target_get_llvm_ctx();

    llvm_ptr = LLVMPointerTypeInContext(llvm_ctx, 0);

    ppar: &*LLVMTypeRef := par;

    if (rt_initializable)
    {
        par[0] := llvm_ptr;

        ++ppar;
    }

    for(i: &unsigned := 0; i < par_count; ++i, ++ppar)
    {
        pt = par_types[i];

        if (v_type_is_special(pt, q_initialize))  *ppar := llvm_ptr;
        else                                      *ppar := v_type_get_llvm_type(pt);
    }

    ret: &LLVMTypeRef := v_undef();

    if (rt_initializable)   ret := LLVMVoidTypeInContext(llvm_ctx);
    else                    ret := v_type_get_llvm_type(rt);

    var_arg = v_type_function_is_var_arg(ft);

    v_return(LLVMFunctionType(ret, par, n, var_arg));
}

//---------------------------------------------------------------------
//- voidc_llvm_build_call_helper ...
//---------------------------------------------------------------------
struct my_temporary_cleaner_ctx_t
{
    typ: *v_type_t;
    val: LLVMValueRef;
    vis: *voidc_visitor_t;
};

my_temporary_cleaner: (void_ctx: *void) -> void
{
    ctx = *(void_ctx: *my_temporary_cleaner_ctx_t);
    defer v_free(&ctx);

    if (!v_type_is_special(ctx.typ, q_terminate))   v_return();     //- ?..

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, v_pointer_type(ctx.typ, 0), ctx.val);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

    v_ast_accept_visitor((stmt: *v_ast_base_t), ctx.vis);
}

//---------------------------------------------------------------------
my_llvm_build_call_helper_intrinsic: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t,
                                      ft: v_type_ptr, fv: LLVMValueRef,
                                      arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                                     ) -> void
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    par_count: &unsigned := par_count;
    arg_count: &unsigned := arg_count;

    tr = v_type_function_get_return_type(ft);

    tr_initializable = v_type_is_special(tr, q_initialize);

    if (tr_initializable)
    {
        ++par_count;
        ++arg_count;
    }

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    tt   = v_get_result_type();
    vtag = v_get_result_value();

    vr: &LLVMValueRef := v_undef();

    builder = v_target_get_builder();

    i: &unsigned := 0;

    if (tr_initializable)
    {
        q = v_quark_from_string;

        expr = v_alloca(v_ast_expr_t);
        v_initialize(expr);
        defer v_terminate(expr);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        switch((vtag: intptr_t))
        {
        case -1:        //- NAMED_VTAG

            t_front = v_get_temporaries_front();

            if (t_front)
            {
                v_save_builder_ip();

                LLVMPositionBuilderBefore(builder, t_front);
            }

            vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

            v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (v_type_is_special(tr, q_terminate))
            {
                v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

                v_ast_make_stmt_defer(stmt, stmt);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
            }

            if (t_front)  v_restore_builder_ip();

            v_break();

        case 0:         //- UNNAMED_VTAG

            vr := v_make_temporary(tr, 0);

            v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (v_type_is_special(tr, q_terminate))
            {
                ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {tr, vr, vis};

                v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
            }

            v_break();

        default:

            //- assert(INVIOLABLE_TAG != tt != UNREFERENCE_TAG);

            vr := vtag;

            if (tt != tr)
            {
                v_set_result_type(tr);
                v_set_result_value(UNNAMED_VTAG);

                v_adopt_result(tt, vtag);           //- ?...

                vr := v_get_result_value();
            }
        }

        values[0] := vr;

        i := 1;
    }

    for (; i < arg_count; ++i)
    {
        j: &unsigned := i;

        if (tr_initializable)   --j;

        if (i < par_count)  v_set_result_type(par_types[j]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(UNNAMED_VTAG);

        v_ast_accept_visitor((arg_ptrs[j]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    ft_ = v_type_get_llvm_type(ft);

    _vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    if (!tr_initializable)  vr := _vr;

    v_set_result_type(tt);
    v_set_result_value(vtag);           //- ?

    v_adopt_result(tr, vr);             //- ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?
}


//---------------------------------------------------------------------
//- adopt_result ...
//---------------------------------------------------------------------
struct my_adopt_result_ctx_t
{
    fun: *((*void, *v_type_t, LLVMValueRef) -> void);
    ctx: *void;
};

my_adopt_result: (void_ctx: *void, type: *v_type_t, value: LLVMValueRef) -> void
{
    tt   = v_get_result_type();
//  vtag = v_get_result_value();            //- ?!??!?!?!?!?!?!?!?!?!

    if (tt == UNREFERENCE_TAG  &&  type == v_static_type_t)
    {
        ctx = *(void_ctx: *my_adopt_result_ctx_t);

        ctx.fun(ctx.ctx, type, value);

        v_return();
    }

    value: &LLVMValueRef := value;

    src_ref = v_type_is_reference(type);

    builder = v_target_get_builder();

    switch((tt: intptr_t))
    {
    case -1:        //- Unreference...

        if (src_ref)
        {
            et = v_type_refptr_get_element_type(type);

            if (v_type_is_array(et))
            {
                //- Special case for C-like array-to-pointer "promotion"...

                et = v_type_array_get_element_type(et);

                as = v_type_refptr_get_address_space(type);

                v_set_result_type(v_pointer_type(et, as));

                value := v_convert_to_type(type, value, v_get_result_type());

                v_break();
            }

            v_set_result_type(et);

            if (!v_type_is_special(et, q_initialize))
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(et), value, "tmp");
            }

            v_break();
        }

        if (v_type_is_array(type))
        {
            //- Special case for C-like array-to-pointer "promotion"...

            et = v_type_array_get_element_type(type);

            v_set_result_type(v_pointer_type(et, 0));           //- 0?

            value := v_convert_to_type(type, value, v_get_result_type());

            v_break();
        }

        //- Fallthrough!

    case 0:         //- Get "as is"...

        v_set_result_type(type);

        v_break();

    default:        //- Adopt...

        if (tt == type)   v_break();

        dst_ref = v_type_is_reference(tt);

        dst_typ: &*v_type_t := tt;

        if (dst_ref)  dst_typ := v_type_refptr_get_element_type(dst_typ);

        src_typ: &*v_type_t := type;

        if (src_ref)
        {
            src_typ := v_type_refptr_get_element_type(src_typ);

            if (v_type_is_array(src_typ)  &&  v_type_is_pointer(dst_typ))
            {
                n0 = LLVMConstNull(v_type_get_llvm_type(v_int_type(32)));

                val: &LLVMValueRef[2] := {n0, n0};

                value := LLVMBuildInBoundsGEP2(builder, v_type_get_llvm_type(src_typ), value, val, 2, "");

                et = v_type_array_get_element_type(src_typ);

                as = v_type_refptr_get_address_space(type);

                src_typ := v_pointer_type(et, as);
            }
            else if (!v_type_is_special(src_typ, q_initialize))
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(src_typ), value, "tmp");
            }
        }

        //- Now value has type src_typ!

        //- assert(!v_type_is_reference(src_typ));
        //- assert(!v_type_is_reference(dst_typ));

        if (src_typ != dst_typ)
        {
            if (dst_typ == v_pointer_type(v_void_type(), 0)  &&  v_type_is_pointer(src_typ))
            {
                value := LLVMBuildPointerCast(builder, value, v_type_get_llvm_type(dst_typ), "");
            }
            else
            {
                value := v_convert_to_type(src_typ, value, dst_typ);        //- "generic" ...
            }
        }

        //- Now value has type dst_typ!

        if (dst_ref)
        {
            if (v_type_is_special(dst_typ, q_initialize))
            {
                expr = v_alloca(v_ast_expr_t, 2);
                v_initialize(expr, 2);
                defer v_terminate(expr, 2);

                stmt = v_alloca(v_ast_stmt_t);
                v_initialize(stmt);
                defer v_terminate(stmt);

                v = v_make_temporary(dst_typ, 0);

                dst_ptr = v_pointer_type(dst_typ, 0);

                v_ast_make_expr_compiled(expr+0, dst_ptr, v);

                v_ast_make_stmt_call(stmt, 0, q_initialize, expr+0, 1);

                vis = voidc_compiler;           //- ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                v_ast_make_expr_compiled(expr+1, dst_ptr, value);

                v_ast_make_stmt_call(stmt, 0, q_copy, expr+0, 2);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                if (v_type_is_special(dst_typ, q_terminate))
                {
                    ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {dst_typ, v, vis};

                    v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
                }

                value := v;
            }
            else
            {
                value := v_make_temporary(dst_typ, value);        //- Sic!!!
            }
        }
    }

    v_set_result_value(value);          //- ?!?!?!?!?!?!?!?!?!?
}

//---------------------------------------------------------------------
my_adopt_result_ctx: &my_adopt_result_ctx_t := v_undef();

{   my_adopt_result_ctx.fun := v_get_adopt_result(&my_adopt_result_ctx.ctx);

    v_set_adopt_result(my_adopt_result, &my_adopt_result_ctx);
}









































//---------------------------------------------------------------------
T = struct { v_std_any_t; };

{
    f = v_type_is_special(T, q_initialize);

    printf("f: %d\n", (f: int));
}

(v_initialize(_)): (*T, size_t) -> void = derive;
(v_terminate(_)):  (*T, size_t) -> void = derive;

{
    u = v_alloca(T);
    v_initialize(u);
    defer v_terminate(u);


}




