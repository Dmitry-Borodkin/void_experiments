{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");
    v_import("level-03");

    v_import("llvm-c/Core.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();
    v_enable_level_03();
}


//=====================================================================
v_internal_fake_utility_intrinsic: (*voidc_visitor_t, aux: *void, *v_ast_base_t,
                                    *v_type_t, LLVMValueRef) -> void
{
    q = v_quark_to_string((aux: v_quark_t));

    printf("v_internal_fake_utility_intrinsic: %s\n", q);

    exit: (int) -> void;

    exit(-1);       //- Sic!
}

{   sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    qnames: &(*const char)[] :=
    {
        "v_initialize",
        "v_terminate",
        "v_copy",
        0
    };

    for (name: &**const char := &qnames[0]; *name; ++name)
    {
        v_std_string_set(sstr, "v.internal.fake_utility.");

        v_std_string_append(sstr, *name);

        q_fake = v_quark_from_string(v_std_string_get(sstr));
        q_name = v_quark_from_string(*name);

        v_add_intrinsic_q(q_fake, v_internal_fake_utility_intrinsic, (q_name: *void));
    }

    //-----------------------------------------------------------------
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool;

//---------------------------------------------------------------------
v_type_check_special: (t: *v_type_t, q: v_quark_t) -> void
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
    case v_type_kind_struct:
        v_break();

    default:
        v_return();
    }

    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    v_std_string_set(sstr, v_quark_to_string(q));

    v_std_string_append(sstr, ".checked");

    q_checked = v_quark_from_string(v_std_string_get(sstr));

    if (v_type_get_property(t, q_checked))  v_return();

    block
    {
        if (v_type_is_array(t))
        {
            v_type_check_special(v_type_array_get_element_type(t), q);
            v_break();
        }

        if (v_type_is_struct(t))
        {
            if (v_type_get_property(t, q))  v_break();

            flag: &bool := false;

            count = v_type_struct_get_element_count(t);
            types = v_type_struct_get_element_types(t);

            for (i: &int := 0; i < count; ++i)
            {
                flag |= v_type_is_special(types[i], q);

                if (flag)   v_break();
            }

            if (flag)
            {
                v_std_string_set(sstr, "v.internal.fake_utility.");

                v_std_string_append(sstr, v_quark_to_string(q));

                q_fake = v_quark_from_string(v_std_string_get(sstr));

                v_util_function_dict_set(t, q, q_fake);
            }

            v_break();
        }

        //- ?!? ...
    }

    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, true);

    v_type_set_property(t, q_checked, any);
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
        v_return(v_type_is_special(v_type_array_get_element_type(t), q));

    case v_type_kind_struct:
        v_break();

    default:
        v_return(false);        //- Sic!!!
    }

    v_type_check_special(t, q);

    v_return(v_type_get_property(t, q) != 0);
}


//=====================================================================
struct compile_stmt_hook_t
{
    fun: *((*voidc_visitor_t, *void, *v_ast_base_t) -> void);
    aux: *void;
};

//---------------------------------------------------------------------
UNNAMED_VTAG = (( 0: intptr_t) : LLVMValueRef);
NAMED_VTAG   = ((-1: intptr_t) : LLVMValueRef);

//---------------------------------------------------------------------
my_compile_stmt: (vis: *voidc_visitor_t, void_aux: *void, self: *v_ast_base_t) -> void
{
    expr = v_ast_stmt_get_expr((self: *v_ast_stmt_t));
    if (v_empty(expr))  v_return();                             //- Sic!

    name = v_ast_stmt_get_name((self: *v_ast_stmt_t));

    if (name  &&  name[0])  v_set_result_value(NAMED_VTAG);     //- Sic!
    else                    v_set_result_value(UNNAMED_VTAG);   //- Sic!

    aux = *(void_aux: *compile_stmt_hook_t);

    aux.fun(vis, aux.aux, self);
}

//---------------------------------------------------------------------
my_stmt_hook: &compile_stmt_hook_t := v_undef();

//---------------------------------------------------------------------
{   vis = voidc_compiler;

    stmt_q = v_quark_from_string("stmt");

    my_stmt_hook.fun := voidc_visitor_get_void_method(vis, stmt_q, &my_stmt_hook.aux);

    voidc_visitor_set_void_method(vis, vis, stmt_q, my_compile_stmt, &my_stmt_hook);
}


//=====================================================================
v_type_function_obtain_llvm_type_hook: (*void, ft: *v_type_t) -> LLVMTypeRef
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    n: &unsigned := par_count;

    rt = v_type_function_get_return_type(ft);

    rt_initializable = v_type_is_special(rt, q_initialize);

    if (rt_initializable) ++n;

    par = v_malloc(LLVMTypeRef, n);
    defer v_free(par);

    llvm_ctx = v_target_get_llvm_ctx();

    llvm_ptr = LLVMPointerTypeInContext(llvm_ctx, 0);

    ppar: &*LLVMTypeRef := par;

    if (rt_initializable)
    {
        par[0] := llvm_ptr;

        ++ppar;
    }

    for(i: &unsigned := 0; i < par_count; ++i, ++ppar)
    {
        pt = par_types[i];

        if (v_type_is_special(pt, q_initialize))  *ppar := llvm_ptr;
        else                                      *ppar := v_type_get_llvm_type(pt);
    }

    ret: &LLVMTypeRef := v_undef();

    if (rt_initializable)   ret := LLVMVoidTypeInContext(llvm_ctx);
    else                    ret := v_type_get_llvm_type(rt);

    var_arg = v_type_function_is_var_arg(ft);

    v_return(LLVMFunctionType(ret, par, n, var_arg));
}

//---------------------------------------------------------------------
{   v_type_set_obtain_llvm_type_fun(v_type_kind_function, v_type_function_obtain_llvm_type_hook, 0);
}


//---------------------------------------------------------------------
//- voidc_llvm_build_call_helper ...
//---------------------------------------------------------------------
struct my_temporary_cleaner_ctx_t
{
    typ: *v_type_t;
    val: LLVMValueRef;
};

my_temporary_cleaner: (void_ctx: *void) -> void
{
    ctx = *(void_ctx: *my_temporary_cleaner_ctx_t);
    defer v_free(&ctx);

    if (!v_type_is_special(ctx.typ, q_terminate))   v_return();     //- ?..

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, v_pointer_type(ctx.typ, 0), ctx.val);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

    v_ast_accept_visitor((stmt: *v_ast_base_t), voidc_compiler);
}

//---------------------------------------------------------------------
my_llvm_build_call_helper_intrinsic: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t,
                                      ft: v_type_ptr, fv: LLVMValueRef,
                                      arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                                     ) -> void
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    par_count: &unsigned := par_count;
    arg_count: &unsigned := arg_count;

    tr = v_type_function_get_return_type(ft);

    tr_initializable = v_type_is_special(tr, q_initialize);

    if (tr_initializable)
    {
        ++par_count;
        ++arg_count;
    }

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    vr: &LLVMValueRef := v_undef();

    builder = v_target_get_builder();

    i: &unsigned := 0;

    if (tr_initializable)
    {
        q = v_quark_from_string;

        expr = v_alloca(v_ast_expr_t);
        v_initialize(expr);
        defer v_terminate(expr);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        switch((vtag: intptr_t))
        {
        case -1:        //- NAMED_VTAG

            t_front = v_get_temporaries_front();

            if (t_front)
            {
                v_save_builder_ip();

                LLVMPositionBuilderBefore(builder, t_front);
            }

            vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

            v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (v_type_is_special(tr, q_terminate))
            {
                v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

                v_ast_make_stmt_defer(stmt, stmt);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
            }

            if (t_front)  v_restore_builder_ip();

            v_break();

        case 0:         //- UNNAMED_VTAG

            vr := v_make_temporary(tr, 0);

            v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (v_type_is_special(tr, q_terminate))
            {
                ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {tr, vr};

                v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
            }

            v_break();

        default:

            //- assert(INVIOLABLE_TAG != ttag != UNREFERENCE_TAG);

            vr := vtag;

            if (ttag != tr)
            {
                v_set_result_type(tr);
                v_set_result_value(vr);                 //- ???

                v_adopt_result(ttag, vtag);             //- ?...

                vr := v_get_result_value();
            }
        }

        values[0] := vr;

        i := 1;
    }

    for (; i < arg_count; ++i)
    {
        j: &unsigned := i;

        if (tr_initializable)   --j;

        if (i < par_count)  v_set_result_type(par_types[j]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(UNNAMED_VTAG);

        v_ast_accept_visitor((arg_ptrs[j]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    ft_ = v_type_get_llvm_type(ft);

    _vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    if (!tr_initializable)  vr := _vr;

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(tr, vr);
}

//---------------------------------------------------------------------
{   q = v_quark_from_string("voidc.llvm_build_call_helper");

    vis = voidc_compiler;

    voidc_visitor_set_intrinsic(vis, vis, q, my_llvm_build_call_helper_intrinsic, 0);
}


//---------------------------------------------------------------------
//- adopt_result ...
//---------------------------------------------------------------------
struct my_adopt_result_ctx_t
{
    fun: *((*void, *v_type_t, LLVMValueRef) -> void);
    ctx: *void;
};

my_adopt_result: (void_ctx: *void, type: *v_type_t, value: LLVMValueRef) -> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    if (ttag == UNREFERENCE_TAG  &&  type == v_static_type_t)
    {
        ctx = *(void_ctx: *my_adopt_result_ctx_t);

        ctx.fun(ctx.ctx, type, value);

        v_return();
    }

    value: &LLVMValueRef := value;

    src_ref = v_type_is_reference(type);

    builder = v_target_get_builder();

    switch((ttag: intptr_t))
    {
    case -1:        //- Unreference...

        if (src_ref)
        {
            et = v_type_refptr_get_element_type(type);

            if (v_type_is_array(et))
            {
                //- Special case for C-like array-to-pointer "promotion"...

                et = v_type_array_get_element_type(et);

                as = v_type_refptr_get_address_space(type);

                v_set_result_type(v_pointer_type(et, as));

                value := v_convert_to_type(type, value, v_get_result_type());

                v_break();
            }

            v_set_result_type(et);

            if (!v_type_is_special(et, q_initialize))
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(et), value, "tmp");
            }

            v_break();
        }

        if (v_type_is_array(type))
        {
            //- Special case for C-like array-to-pointer "promotion"...

            et = v_type_array_get_element_type(type);

            v_set_result_type(v_pointer_type(et, 0));           //- 0?

            value := v_convert_to_type(type, value, v_get_result_type());

            v_break();
        }

        //- Fallthrough!

    case 0:         //- Get "as is"...

        v_set_result_type(type);

        v_break();

    default:        //- Adopt...

        if (ttag == type)
        {
            if (v_type_is_special(type, q_initialize))
            block
            {
                if (vtag == UNNAMED_VTAG)   v_break();
                if (vtag == NAMED_VTAG)     v_break();
                if (vtag == value)          v_break();

                expr = v_alloca(v_ast_expr_t, 2);
                v_initialize(expr, 2);
                defer v_terminate(expr, 2);

                stmt = v_alloca(v_ast_stmt_t);
                v_initialize(stmt);
                defer v_terminate(stmt);

                ttag_ptr = v_pointer_type(ttag, 0);

                v_ast_make_expr_compiled(expr+0, ttag_ptr, vtag);
                v_ast_make_expr_compiled(expr+1, ttag_ptr, value);

                v_ast_make_stmt_call(stmt, 0, q_copy, expr+0, 2);

                vis = voidc_compiler;                           //- ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                value := vtag;
            }

            v_break();
        }

        dst_ref = v_type_is_reference(ttag);

        dst_typ: &*v_type_t := ttag;

        if (dst_ref)  dst_typ := v_type_refptr_get_element_type(dst_typ);

        src_typ: &*v_type_t := type;

        if (src_ref)
        {
            src_typ := v_type_refptr_get_element_type(src_typ);

            if (v_type_is_array(src_typ)  &&  v_type_is_pointer(dst_typ))
            {
                n0 = LLVMConstNull(v_type_get_llvm_type(v_int_type(32)));

                val: &LLVMValueRef[2] := {n0, n0};

                value := LLVMBuildInBoundsGEP2(builder, v_type_get_llvm_type(src_typ), value, val, 2, "");

                et = v_type_array_get_element_type(src_typ);

                as = v_type_refptr_get_address_space(type);

                src_typ := v_pointer_type(et, as);
            }
            else if (!v_type_is_special(src_typ, q_initialize))
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(src_typ), value, "tmp");
            }
        }

        //- Now value has type src_typ!

        //- assert(!v_type_is_reference(src_typ));
        //- assert(!v_type_is_reference(dst_typ));

        if (src_typ != dst_typ)
        {
            if (dst_typ == v_pointer_type(v_void_type(), 0)  &&  v_type_is_pointer(src_typ))
            {
                value := LLVMBuildPointerCast(builder, value, v_type_get_llvm_type(dst_typ), "");
            }
            else
            {
                value := v_convert_to_type(src_typ, value, dst_typ);        //- "generic" ...
            }
        }

        //- Now value has type dst_typ!

        if (dst_ref)
        {
            if (v_type_is_special(dst_typ, q_initialize))
            {
                expr = v_alloca(v_ast_expr_t, 2);
                v_initialize(expr, 2);
                defer v_terminate(expr, 2);

                stmt = v_alloca(v_ast_stmt_t);
                v_initialize(stmt);
                defer v_terminate(stmt);

                v = v_make_temporary(dst_typ, 0);

                dst_ptr = v_pointer_type(dst_typ, v_type_refptr_get_address_space(ttag));

                v_ast_make_expr_compiled(expr+0, dst_ptr, v);

                v_ast_make_stmt_call(stmt, 0, q_initialize, expr+0, 1);

                vis = voidc_compiler;                           //- ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                v_ast_make_expr_compiled(expr+1, dst_ptr, value);

                v_ast_make_stmt_call(stmt, 0, q_copy, expr+0, 2);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                if (v_type_is_special(dst_typ, q_terminate))
                {
                    ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {dst_typ, v};

                    v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
                }

                value := v;
            }
            else
            {
                value := v_make_temporary(dst_typ, value);        //- Sic!!!
            }
        }
    }

    v_set_result_value(value);          //- ?..
}

//---------------------------------------------------------------------
my_adopt_result_ctx: &my_adopt_result_ctx_t := v_undef();

{   my_adopt_result_ctx.fun := v_get_adopt_result(&my_adopt_result_ctx.ctx);

    v_set_adopt_result(my_adopt_result, &my_adopt_result_ctx);
}


//=====================================================================
struct my_prepare_function_parameters_ctx_t
{
    fun: *((*void, LLVMValueRef, intptr_t, *const char, *v_type_t, *v_ast_generic_list_t) -> void);
    aux: *void;
};

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("voidc_internal_return_value_q", q_ref, q("voidc.internal_return_value"));
}

//---------------------------------------------------------------------
my_prepare_function_parameters_fun: (aux: *void, fun: LLVMValueRef,
                                     qualif: intptr_t,
                                     fun_name: *const char,
                                     fun_type: *v_type_t,
                                     fun_args: *v_ast_generic_list_t
                                    ) -> void
{
    tr = v_type_function_get_return_type(fun_type);

    if (!v_type_is_special(tr, q_initialize))
    {
        ctx = *(aux: *my_prepare_function_parameters_ctx_t);

        ctx.fun(ctx.aux, fun, qualif, fun_name, fun_type, fun_args);

        v_return();
    }

    vr = LLVMGetParam(fun, 0);

    v_add_variable_q(voidc_internal_return_value_q, tr, vr);         //- Sic!

    count = v_type_function_get_param_count(fun_type);
    types = v_type_function_get_param_types(fun_type);

    for (i: &int := 0; i < count; ++i)
    {
        item = (v_list_get_item(fun_args, i) : *v_ast_generic_list_t);

        etmp = (v_list_get_item(item, 0) : *v_ast_expr_t);

        if (!v_empty(etmp))
        {
            pname = v_ast_expr_identifier_get_name(etmp);

            v_add_parameter_name(fun, i+1, pname, types[i]);
        }
    }
}

//---------------------------------------------------------------------
my_prepare_function_parameters_ctx: &my_prepare_function_parameters_ctx_t := v_undef();

//---------------------------------------------------------------------
{   q = v_quark_from_string("v.prepare_function_parameters");

    ctx = my_prepare_function_parameters_ctx;

    vis = voidc_compiler;

    ctx.fun := voidc_visitor_get_intrinsic(vis, q, &ctx.aux);

    voidc_visitor_set_intrinsic(vis, vis, q, my_prepare_function_parameters_fun, &ctx);
}


//=====================================================================
struct my_return_intrinsic_ctx_t
{
    fun: *((*voidc_visitor_t, *void, *v_ast_base_t) -> void);
    aux: *void;
};

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("voidc_internal_branch_target_leave_q", q_ref, q("voidc.internal_branch_target_leave"));
}

//---------------------------------------------------------------------
my_return_intrinsic_fun: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t) -> void
{
    call = (self: *v_ast_expr_t);

    arg_list = v_ast_expr_call_get_arg_list(call);

    builder = v_target_get_builder();

    args_count = v_list_get_size(arg_list);

    if (args_count)
    {
        ret_type = v_get_variable_type_q(voidc_internal_return_value_q);

        if (!v_type_is_special(ret_type, q_initialize))
        {
            ctx = *(aux: *my_return_intrinsic_ctx_t);

            ctx.fun(vis, ctx.aux, self);

            v_return();
        }

        ret_value = v_get_variable_value_q(voidc_internal_return_value_q);

        v_set_result_type(ret_type);
        v_set_result_value(ret_value);

        arg0 = v_list_get_item(arg_list, 0);

        v_ast_accept_visitor((arg0: *v_ast_base_t), vis);
    }

    leave_bv = v_get_variable_value_q(voidc_internal_branch_target_leave_q);
    leave_b  = LLVMValueAsBasicBlock(leave_bv);

    LLVMBuildBr(builder, leave_b);
}

//---------------------------------------------------------------------
my_return_intrinsic_ctx: &my_return_intrinsic_ctx_t := v_undef();

//---------------------------------------------------------------------
{   q = v_quark_from_string("v_return");

    ctx = my_return_intrinsic_ctx;

    ctx.fun := v_get_intrinsic_q(q, &ctx.aux);

    v_add_intrinsic_q(q, my_return_intrinsic_fun, &ctx);
}


//=====================================================================
v_get_return_value_intrinsic: (*voidc_visitor_t, *void, *v_ast_base_t) -> void
{
    ret_type  = v_get_variable_type_q(voidc_internal_return_value_q);
    ret_value = v_get_variable_value_q(voidc_internal_return_value_q);

    v_set_result_type(v_reference_type(ret_type, 0));
    v_set_result_value(ret_value);
}

//---------------------------------------------------------------------
{   v_add_intrinsic("v_get_return_value", v_get_return_value_intrinsic, 0);
}


//---------------------------------------------------------------------
v_get_object_pointer_intrinsic: (vis: *voidc_visitor_t, *void, self: *v_ast_base_t) -> void
{
    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(UNNAMED_VTAG);

    v_ast_accept_visitor((v_list_get_item(arg_list, 0) : *v_ast_base_t), vis);

    ret_type  = v_get_result_type();
    ret_value = v_get_result_value();

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(v_pointer_type(ret_type, 0), ret_value);
}

//---------------------------------------------------------------------
{   v_add_intrinsic("v_get_object_pointer", v_get_object_pointer_intrinsic, 0);
}






//=====================================================================
//- ...
//=====================================================================

//---------------------------------------------------------------------
T = struct { v_std_any_t; };

{
    f = v_type_is_special(T, q_initialize);

    printf("f: %d\n", (f: int));
}

(v_initialize(_)): (*T, size_t) -> void = derive;
(v_terminate(_)):  (*T, size_t) -> void = derive;

(v_copy(_)): (*T, *const T, size_t) -> void = derive;

{
    u = v_alloca(T);
    v_initialize(u);
    defer v_terminate(u);


}


//---------------------------------------------------------------------
//{ v_debug_print_module(1); }

//---------------------------------------------------------------------
mk_expr_identifier: (id: *const char) -> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_identifier(&ret, id);
}

//---------------------------------------------------------------------
mk_expr_integer: (num: intptr_t) -> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_integer(&ret, num);
}

//---------------------------------------------------------------------
mk_expr_string: (str: *const char) -> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_string(&ret, str);
}

//---------------------------------------------------------------------
mk_expr_char: (c: char32_t) -> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_char(&ret, c);
}


//---------------------------------------------------------------------
mk_expr_compiled: (t: *v_type_t, v: LLVMValueRef) -> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_compiled(&ret, t, v);
}


//---------------------------------------------------------------------
mk_expr_call: (fun: v_ast_expr_t, args: v_ast_expr_list_t) -> v_ast_expr_t
{
    ret = v_get_return_value();

    _fun  = v_get_object_pointer(fun);
    _args = v_get_object_pointer(args);

    v_ast_make_expr_call(&ret, _fun, _args);
}


//---------------------------------------------------------------------
mk_expr_list_intrinsic: (vis: *voidc_visitor_t, *void, self: *v_ast_base_t) -> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    tr = v_find_type("v_ast_expr_list_t");

    vr: &LLVMValueRef := v_undef();

    builder = v_target_get_builder();

    {   stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        switch((vtag: intptr_t))
        {
        case -1:        //- NAMED_VTAG
          {
            t_front = v_get_temporaries_front();

            if (t_front)
            {
                v_save_builder_ip();

                LLVMPositionBuilderBefore(builder, t_front);
            }

            vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

            er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

            expr = v_get_object_pointer(er);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

            v_ast_make_stmt_defer(stmt, stmt);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (t_front)  v_restore_builder_ip();

            v_break();
          }

        case 0:         //- UNNAMED_VTAG
          {
            vr := v_make_temporary(tr, 0);

            er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

            expr = v_get_object_pointer(er);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {tr, vr};

            v_add_temporary_cleaner(my_temporary_cleaner, &ctx);

            v_break();
          }

        default:

            //- assert(INVIOLABLE_TAG != ttag != UNREFERENCE_TAG);

            vr := vtag;

            if (ttag != tr)
            {
                v_set_result_type(tr);
                v_set_result_value(vr);                 //- ???

                v_adopt_result(ttag, vtag);             //- ?...

                vr := v_get_result_value();
            }
        }
    }

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    args_count = v_list_get_size(arg_list);

    if (args_count == 0)
    {
        er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        expr = v_get_object_pointer(er);

        list = v_alloca(v_ast_expr_list_t);
        v_initialize(list);
        defer v_terminate(list);

        v_make_list(list, expr, 1);

        e = mk_expr_call(mk_expr_identifier("v_make_list_nil"), list);      //- list ???

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        v_ast_accept_visitor((v_get_object_pointer(e): *v_ast_base_t), vis);

        v_set_result_type(tr);
        v_set_result_value(vr);

        v_return();
    }


    lltyp: &LLVMTypeRef :=  v_undef();

    llvm_stacksave_f = v_obtain_function("llvm.stacksave", &lltyp);

    blk = LLVMBuildCall2(builder, lltyp, llvm_stacksave_f, 0, 0, "blk");


    size_t_ = v_type_get_llvm_type(size_t);

    args_count_ = LLVMConstInt(size_t_, args_count, 0);

    v_ast_expr_t_ = v_type_get_llvm_type(v_ast_expr_t);

    buf_v = LLVMBuildArrayAlloca(builder, v_ast_expr_t_, args_count_, "buf_v");

    {   expr = v_alloca(v_ast_expr_t, 2);
        v_initialize(expr, 2);
        defer v_terminate(expr, 2);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        v_ast_make_expr_compiled(expr+0, v_pointer_type(v_ast_expr_t, 0), buf_v);

        v_ast_make_expr_integer(expr+1, args_count);

        v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 2);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }

    for (i: &int := 0; i < args_count; ++i)
    {
        i_ = LLVMConstInt(size_t_, i, 0);

        ei = LLVMBuildGEP2(builder, v_ast_expr_t_, buf_v, &i_, 1, "ei");

        v_set_result_type(v_ast_expr_t);
        v_set_result_value(ei);

        expr = v_list_get_item(arg_list, i);

        v_ast_accept_visitor((expr: *v_ast_base_t), vis);
    }


    {   er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        expr = v_get_object_pointer(er);

        list = v_alloca(v_ast_expr_list_t);
        v_initialize(list);
        defer v_terminate(list);

        v_make_list(list, expr, 1);

        eb = mk_expr_compiled(v_pointer_type(v_ast_expr_t, 0), buf_v);

        expr = v_get_object_pointer(eb);

        v_list_append(list, list, expr);

        en = mk_expr_integer(args_count);

        expr = v_get_object_pointer(en);

        v_list_append(list, list, expr);

        e = mk_expr_call(mk_expr_identifier("v_make_list"), list);      //- list ???

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        v_ast_accept_visitor((v_get_object_pointer(e): *v_ast_base_t), vis);
    }


    {   expr = v_alloca(v_ast_expr_t, 2);
        v_initialize(expr, 2);
        defer v_terminate(expr, 2);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        v_ast_make_expr_compiled(expr+0, v_pointer_type(v_ast_expr_t, 0), buf_v);

        v_ast_make_expr_integer(expr+1, args_count);

        v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 2);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }


    llvm_stackrestore_f = v_obtain_function("llvm.stackrestore", &lltyp);

    LLVMBuildCall2(builder, lltyp, llvm_stackrestore_f, &blk, 1, "");


    v_set_result_type(tr);
    v_set_result_value(vr);
}

//---------------------------------------------------------------------
{   v_add_intrinsic("mk_expr_list", mk_expr_list_intrinsic, 0);
}


//---------------------------------------------------------------------
mk_stmt: (name: *const char, expr: v_ast_expr_t) -> v_ast_stmt_t
{
    ret = v_get_return_value();

    _expr = v_get_object_pointer(expr);

    v_ast_make_stmt(&ret, name, _expr);
}


//---------------------------------------------------------------------
mk_stmt_list_intrinsic: (vis: *voidc_visitor_t, *void, self: *v_ast_base_t) -> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    tr = v_find_type("v_ast_stmt_list_t");

    vr: &LLVMValueRef := v_undef();

    builder = v_target_get_builder();

    {   stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        switch((vtag: intptr_t))
        {
        case -1:        //- NAMED_VTAG
          {
            t_front = v_get_temporaries_front();

            if (t_front)
            {
                v_save_builder_ip();

                LLVMPositionBuilderBefore(builder, t_front);
            }

            vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

            er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

            expr = v_get_object_pointer(er);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

            v_ast_make_stmt_defer(stmt, stmt);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            if (t_front)  v_restore_builder_ip();

            v_break();
          }

        case 0:         //- UNNAMED_VTAG
          {
            vr := v_make_temporary(tr, 0);

            er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

            expr = v_get_object_pointer(er);

            v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {tr, vr};

            v_add_temporary_cleaner(my_temporary_cleaner, &ctx);

            v_break();
          }

        default:

            //- assert(INVIOLABLE_TAG != ttag != UNREFERENCE_TAG);

            vr := vtag;

            if (ttag != tr)
            {
                v_set_result_type(tr);
                v_set_result_value(vr);                 //- ???

                v_adopt_result(ttag, vtag);             //- ?...

                vr := v_get_result_value();
            }
        }
    }

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    args_count = v_list_get_size(arg_list);

    if (args_count == 0)
    {
        er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        lst = mk_expr_list(er);

        e = mk_expr_call(mk_expr_identifier("v_make_list_nil"), lst);

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        v_ast_accept_visitor((v_get_object_pointer(e): *v_ast_base_t), vis);

        v_set_result_type(tr);
        v_set_result_value(vr);

        v_return();
    }


    lltyp: &LLVMTypeRef :=  v_undef();

    llvm_stacksave_f = v_obtain_function("llvm.stacksave", &lltyp);

    blk = LLVMBuildCall2(builder, lltyp, llvm_stacksave_f, 0, 0, "blk");


    size_t_ = v_type_get_llvm_type(size_t);

    args_count_ = LLVMConstInt(size_t_, args_count, 0);

    v_ast_stmt_t_ = v_type_get_llvm_type(v_ast_stmt_t);

    buf_v = LLVMBuildArrayAlloca(builder, v_ast_stmt_t_, args_count_, "buf_v");

    {   expr = v_alloca(v_ast_expr_t, 2);
        v_initialize(expr, 2);
        defer v_terminate(expr, 2);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        v_ast_make_expr_compiled(expr+0, v_pointer_type(v_ast_stmt_t, 0), buf_v);

        v_ast_make_expr_integer(expr+1, args_count);

        v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 2);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }

    for (i: &int := 0; i < args_count; ++i)
    {
        i_ = LLVMConstInt(size_t_, i, 0);

        si = LLVMBuildGEP2(builder, v_ast_stmt_t_, buf_v, &i_, 1, "si");

        v_set_result_type(v_ast_stmt_t);
        v_set_result_value(si);

        stmt = v_list_get_item(arg_list, i);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }

    {   er = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        lst = mk_expr_list
        (
            mk_expr_compiled(v_pointer_type(tr, 0), vr),

            mk_expr_compiled(v_pointer_type(v_ast_expr_t, 0), buf_v),

            mk_expr_integer(args_count)
        );

        e = mk_expr_call(mk_expr_identifier("v_make_list"), lst);

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        v_ast_accept_visitor((v_get_object_pointer(e): *v_ast_base_t), vis);
    }


    {   expr = v_alloca(v_ast_expr_t, 2);
        v_initialize(expr, 2);
        defer v_terminate(expr, 2);

        stmt = v_alloca(v_ast_stmt_t);
        v_initialize(stmt);
        defer v_terminate(stmt);

        v_ast_make_expr_compiled(expr+0, v_pointer_type(v_ast_stmt_t, 0), buf_v);

        v_ast_make_expr_integer(expr+1, args_count);

        v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 2);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }


    llvm_stackrestore_f = v_obtain_function("llvm.stackrestore", &lltyp);

    LLVMBuildCall2(builder, lltyp, llvm_stackrestore_f, &blk, 1, "");


    v_set_result_type(tr);
    v_set_result_value(vr);
}

//---------------------------------------------------------------------
{   v_add_intrinsic("mk_stmt_list", mk_stmt_list_intrinsic, 0);
}


//---------------------------------------------------------------------
(_:=_): (p: &v_ast_expr_t, v: v_ast_expr_t) -> &v_ast_expr_t
{
    v_copy(&p, v_get_object_pointer(v));

    v_return(p);
}

(_:=_): (p: &v_ast_expr_list_t, v: v_ast_expr_list_t) -> &v_ast_expr_list_t
{
    v_copy(&p, v_get_object_pointer(v));

    v_return(p);
}

(_:=_): (p: &v_ast_stmt_t, v: v_ast_stmt_t) -> &v_ast_stmt_t
{
    v_copy(&p, v_get_object_pointer(v));

    v_return(p);
}

(_:=_): (p: &v_ast_stmt_list_t, v: v_ast_stmt_list_t) -> &v_ast_stmt_list_t
{
    v_copy(&p, v_get_object_pointer(v));

    v_return(p);
}

//---------------------------------------------------------------------
(_+=_): (l: &v_ast_expr_list_t, e: v_ast_expr_t) -> &v_ast_expr_list_t
{
    v_list_append(&l, &l, v_get_object_pointer(e));

    v_return(l);
}

(_+=_): (l: &v_ast_stmt_list_t, s: v_ast_stmt_t) -> &v_ast_stmt_list_t
{
    v_list_append(&l, &l, v_get_object_pointer(s));

    v_return(l);
}





//---------------------------------------------------------------------
{ v_debug_print_module(1); }
{
    e = mk_expr_call(mk_expr_identifier("fun"), mk_expr_list());

//    a = mk_expr_identifier("a");
//    b = mk_expr_identifier("b");
//    c = mk_expr_identifier("c");
//
//    l = mk_expr_list(a, b, c);

    l = mk_expr_list
    (
        mk_expr_identifier("a"),
        mk_expr_identifier("b"),
        mk_expr_identifier("c")
    );

    f = mk_expr_call
    (
        mk_expr_identifier("foo"),
        mk_expr_list
        (
            mk_expr_integer(42),
            mk_expr_identifier("v"),
            mk_expr_call
            (
                mk_expr_identifier("bar"),
                mk_expr_list
                (
                    mk_expr_identifier("baz")
                )
            )
        )
    );
}


//---------------------------------------------------------------------
//{ v_debug_print_module(1); }
{
    e: &v_ast_expr_t := v_undef();
    v_initialize(&e);
    defer v_terminate(&e);

    e := mk_expr_identifier("foo");

    printf("e: %p[%p, %p]\n", &e, (e[0][0]: *void), (e[0][1]: *void));

    l: &v_ast_expr_list_t := v_undef();
    v_initialize(&l);
    defer v_terminate(&l);

    l := mk_expr_list();

    l += mk_expr_identifier("a");
    l += mk_expr_identifier("b");
    l += mk_expr_identifier("c");

    e := mk_expr_call(e, l);


    printf("e: %p[%p, %p]\n", &e, (e[0][0]: *void), (e[0][1]: *void));

    f = *v_ast_expr_call_get_fun_expr(&e);

    printf("f: %p[%p, %p]\n", &f, (f[0][0]: *void), (f[0][1]: *void));


}








