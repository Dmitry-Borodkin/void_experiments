{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");
    v_import("level-03");

    v_import("llvm-c/Core.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();
    v_enable_level_03();
}


//=====================================================================
v_internal_fake_utility_intrinsic: (*voidc_visitor_t, aux: *void, *v_ast_base_t,
                                    *v_type_t, LLVMValueRef) -> void
{
    q = v_quark_to_string((aux: v_quark_t));

    printf("v_internal_fake_utility_intrinsic: %s\n", q);

    exit: (int) -> void;

    exit(-1);       //- Sic!
}

{   sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    qnames: &(*const char)[] :=
    {
        "v_initialize",
        "v_terminate",
        "v_copy",
        0
    };

    for (name: &**const char := &qnames[0]; *name; ++name)
    {
        v_std_string_set(sstr, "v.internal.fake_utility.");

        v_std_string_append(sstr, *name);

        q_fake = v_quark_from_string(v_std_string_get(sstr));
        q_name = v_quark_from_string(*name);

        v_add_intrinsic_q(q_fake, v_internal_fake_utility_intrinsic, (q_name: *void));
    }

    //-----------------------------------------------------------------
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool;

//---------------------------------------------------------------------
v_type_check_special: (t: *v_type_t, q: v_quark_t) -> void
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
    case v_type_kind_struct:
        v_break();

    default:
        v_return();
    }

    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    v_std_string_set(sstr, v_quark_to_string(q));

    v_std_string_append(sstr, ".checked");

    q_checked = v_quark_from_string(v_std_string_get(sstr));

    if (v_type_get_property(t, q_checked))  v_return();

    block
    {
        if (v_type_is_array(t))
        {
            v_type_check_special(v_type_array_get_element_type(t), q);
            v_break();
        }

        if (v_type_is_struct(t))
        {
            if (v_type_get_property(t, q))  v_break();

            flag: &bool := false;

            count = v_type_struct_get_element_count(t);
            types = v_type_struct_get_element_types(t);

            for (i: &int := 0; i < count; ++i)
            {
                flag |= v_type_is_special(types[i], q);

                if (flag)   v_break();
            }

            if (flag)
            {
                v_std_string_set(sstr, "v.internal.fake_utility.");

                v_std_string_append(sstr, v_quark_to_string(q));

                q_fake = v_quark_from_string(v_std_string_get(sstr));

                v_util_function_dict_set(t, q, q_fake);
            }

            v_break();
        }

        //- ?!? ...
    }

    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, true);

    v_type_set_property(t, q_checked, any);
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) -> bool
{
    switch(v_type_get_kind(t))
    {
    case v_type_kind_array:
        v_return(v_type_is_special(v_type_array_get_element_type(t), q));

    case v_type_kind_struct:
        v_break();

    default:
        v_return(false);        //- Sic!!!
    }

    v_type_check_special(t, q);

    v_return(v_type_get_property(t, q) != 0);
}


//=====================================================================
struct compile_stmt_hook_t
{
    fun: *((*voidc_visitor_t, *void, *v_ast_base_t) -> void);
    aux: *void;
};

//---------------------------------------------------------------------
UNNAMED_VTAG = ( 0: LLVMValueRef);
NAMED_VTAG   = (-1: LLVMValueRef);

//---------------------------------------------------------------------
my_compile_stmt: (vis: *voidc_visitor_t, void_aux: *void, self: *v_ast_base_t) -> void
{
    expr = v_ast_stmt_get_expr((self: *v_ast_stmt_t));
    if (v_empty(expr))  v_return();                             //- Sic!

    name = v_ast_stmt_get_name((self: *v_ast_stmt_t));

    if (name  &&  name[0])  v_set_result_value(NAMED_VTAG);     //- Sic!
    else                    v_set_result_value(UNNAMED_VTAG);   //- Sic!

    aux = *(void_aux: *compile_stmt_hook_t);

    aux.fun(vis, aux.aux, self);
}

//---------------------------------------------------------------------
my_stmt_hook: &compile_stmt_hook_t := v_undef();

//---------------------------------------------------------------------
{   vis = voidc_compiler;

    stmt_q = v_quark_from_string("stmt");

    my_stmt_hook.fun := voidc_visitor_get_void_method(vis, stmt_q, &my_stmt_hook.aux);

    voidc_visitor_set_void_method(vis, vis, stmt_q, my_compile_stmt, &my_stmt_hook);
}


//=====================================================================
v_type_function_obtain_llvm_type_hook: (*void, ft: *v_type_t) -> LLVMTypeRef
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    n: &unsigned := par_count;

    rt = v_type_function_get_return_type(ft);

    rt_initializable = v_type_is_special(rt, q_initialize);

    if (rt_initializable) ++n;

    par = v_malloc(LLVMTypeRef, n);
    defer v_free(par);

    llvm_ctx = v_target_get_llvm_ctx();

    llvm_ptr = LLVMPointerTypeInContext(llvm_ctx, 0);

    ppar: &*LLVMTypeRef := par;

    if (rt_initializable)
    {
        par[0] := llvm_ptr;

        ++ppar;
    }

    for(i: &unsigned := 0; i < par_count; ++i, ++ppar)
    {
        pt = par_types[i];

        if (v_type_is_special(pt, q_initialize))  *ppar := llvm_ptr;
        else                                      *ppar := v_type_get_llvm_type(pt);
    }

    ret: &LLVMTypeRef := v_undef();

    if (rt_initializable)   ret := LLVMVoidTypeInContext(llvm_ctx);
    else                    ret := v_type_get_llvm_type(rt);

    var_arg = v_type_function_is_var_arg(ft);

    v_return(LLVMFunctionType(ret, par, n, var_arg));
}

//---------------------------------------------------------------------
//- voidc_llvm_build_call_helper ...
//---------------------------------------------------------------------
struct my_temporary_cleaner_ctx_t
{
    typ: *v_type_t;
    val: LLVMValueRef;
    vis: *voidc_visitor_t;
};

my_temporary_cleaner: (void_ctx: *void) -> void
{
    ctx = *(void_ctx: *my_temporary_cleaner_ctx_t);
    defer v_free(&ctx);

    if (!v_type_is_special(ctx.typ, q_terminate))   v_return();     //- ?..

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, v_pointer_type(ctx.typ, 0), ctx.val);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

    v_ast_accept_visitor((stmt: *v_ast_base_t), ctx.vis);
}

//---------------------------------------------------------------------
my_llvm_build_call_helper_intrinsic: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t,
                                      ft: v_type_ptr, fv: LLVMValueRef,
                                      arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                                     ) -> void
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    par_count: &unsigned := par_count;
    arg_count: &unsigned := arg_count;

    tr = v_type_function_get_return_type(ft);

    tr_initializable = v_type_is_special(tr, q_initialize);

    if (tr_initializable)
    {
        ++par_count;
        ++arg_count;
    }

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    tt   = v_get_result_type();
    vtag = v_get_result_value();

    vr: &LLVMValueRef := v_undef();

    builder = v_target_get_builder();

    for (i: &unsigned := 0; i < arg_count; ++i)
    {
        if (tr_initializable  &&  i == 0)
        {
            q = v_quark_from_string;

            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            stmt = v_alloca(v_ast_stmt_t);
            v_initialize(stmt);
            defer v_terminate(stmt);

            switch((vtag: intptr_t))
            {
            case -1:        //- NAMED_VTAG

                t_front = v_get_temporaries_front();

                if (t_front)
                {
                    v_save_builder_ip();

                    LLVMPositionBuilderBefore(builder, t_front);
                }

                vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

                v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

                v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                if (v_type_is_special(tr, q_terminate))
                {
                    v_ast_make_stmt_call(stmt, 0, q_terminate, expr, 1);

                    v_ast_make_stmt_defer(stmt, stmt);

                    v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
                }

                if (t_front)  v_restore_builder_ip();

                v_break();

            case 0:         //- UNNAMED_VTAG

                vr := v_make_temporary(tr, 0);

                v_ast_make_expr_compiled(expr, v_pointer_type(tr, 0), vr);

                v_ast_make_stmt_call(stmt, 0, q_initialize, expr, 1);

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                if (v_type_is_special(tr, q_terminate))
                {
                    ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {tr, vr, vis};

                    v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
                }

                v_break();

            default:

                vr := vtag;
            }

            values[0] := vr;

            v_continue();
        }

        j: &unsigned := i;

        if (tr_initializable)   --j;

        if (i < par_count)  v_set_result_type(par_types[j]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(UNNAMED_VTAG);

        v_ast_accept_visitor((arg_ptrs[j]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    ft_ = v_type_get_llvm_type(ft);

    _vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    if (!tr_initializable)  vr := _vr;

    v_set_result_type(tt);
    v_set_result_value(vtag);       //- ?

    v_adopt_result(tr, vr);                 //- ?!?!?!?!?!?!?!?!?!?!?!?!?!?!?!?
}
















//---------------------------------------------------------------------






























//---------------------------------------------------------------------
T = struct { v_std_any_t; };

{
    f = v_type_is_special(T, q_initialize);

    printf("f: %d\n", (f: int));
}

(v_initialize(_)): (*T, size_t) -> void = derive;
(v_terminate(_)):  (*T, size_t) -> void = derive;

{
    u = v_alloca(T);
    v_initialize(u);
    defer v_terminate(u);


}




