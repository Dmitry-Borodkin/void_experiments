{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();
}


//---------------------------------------------------------------------
opk_assign   = 0;
opk_logical  = 1;
opk_relation = 2;
opk_binary   = 3;
opk_unary    = 4;

op_table_item_t = v_struct("struct.op_table_item")
(
    *const char,    //- 0 - Name
    int,            //- 1 - Kind
    v_quark_t,      //- 2 - Quark (left)
    v_quark_t       //- 3 - Quark (right)

                    //- ? - ???
);

OP_TABLE_SIZE = 41;

op_table: &op_table_item_t[OP_TABLE_SIZE] :=
{
    {"op_infix_assign",      opk_assign   },
    {"op_infix_add_assign",  opk_assign   },
    {"op_infix_sub_assign",  opk_assign   },
    {"op_infix_mul_assign",  opk_assign   },
    {"op_infix_div_assign",  opk_assign   },
    {"op_infix_rem_assign",  opk_assign   },
    {"op_infix_shl_assign",  opk_assign   },
    {"op_infix_shr_assign",  opk_assign   },
    {"op_infix_and_assign",  opk_assign   },
    {"op_infix_xor_assign",  opk_assign   },
    {"op_infix_or_assign",   opk_assign   },

    {"op_infix_logical_or",  opk_logical  },
    {"op_infix_logical_and", opk_logical  },

    {"op_infix_lt",          opk_relation },
    {"op_infix_le",          opk_relation },
    {"op_infix_gt",          opk_relation },
    {"op_infix_ge",          opk_relation },
    {"op_infix_eq",          opk_relation },
    {"op_infix_ne",          opk_relation },

    {"op_infix_or",          opk_binary   },
    {"op_infix_xor",         opk_binary   },
    {"op_infix_and",         opk_binary   },

    {"op_infix_shl",         opk_binary   },
    {"op_infix_shr",         opk_binary   },
    {"op_infix_add",         opk_binary   },
    {"op_infix_sub",         opk_binary   },
    {"op_infix_mul",         opk_binary   },
    {"op_infix_div",         opk_binary   },
    {"op_infix_rem",         opk_binary   },

    {"op_prefix_inc",        opk_unary    },
    {"op_prefix_dec",        opk_unary    },
    {"op_prefix_plus",       opk_unary    },
    {"op_prefix_minus",      opk_unary    },
    {"op_prefix_star",       opk_unary    },
    {"op_prefix_amp",        opk_unary    },
    {"op_prefix_bang",       opk_unary    },
    {"op_prefix_tilda",      opk_unary    },

    {"op_postfix_inc",       opk_unary    },
    {"op_postfix_dec",       opk_unary    },
    {"op_postfix_call",      opk_unary    },
    {"op_postfix_index",     opk_unary    }
};

{   sstr = v_alloca(v_util_opaque_std_string);
    v_initialize(sstr);
    defer v_terminate(sstr);

    int_ = v_type_get_llvm_type(int);

    for (i: &int := 0; i < OP_TABLE_SIZE; ++i)
    {
        op_table[i][2] := v_quark_from_string(op_table[i][0]);

        if (op_table[i][1] == opk_binary)
        {
            v_std_string_set(sstr, op_table[i][0]);

            v_std_string_append(sstr, ".right");

            op_table[i][3] := v_quark_from_string(v_std_string_get(sstr));
        }

        v_std_string_set(sstr, "id");

        v_std_string_append(sstr, op_table[i][0]+2);

        v_add_constant(v_std_string_get(sstr), int, LLVMConstInt(int_, i, 0));
    }

    //-------------------------------------------------------------
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("expr_call_tag",       q_ref, q("ast_expr_call_t"));
    v_add_symbol("expr_identifier_tag", q_ref, q("ast_expr_identifier_t"));
}


//---------------------------------------------------------------------
lookup_function_dict: (vis: voidc_visitor_ptr, q: v_quark_t, t: v_type_ptr,
                       void_fun: &*void, void_aux: &*void,
                       f: &LLVMValueRef, ft: &v_type_ptr
                      ) -> bool
{
    fname = v_util_function_dict_get(q, t);
    if (!fname) v_return(false);

    if (void_fun := v_get_intrinsic(fname, &void_aux))  v_return(true);

    if (void_fun := voidc_visitor_get_intrinsic(vis, fname, &void_aux)) v_return(true);

    ft := v_find_symbol_type(fname);

    if (!ft)  v_return(false);

    module = v_get_module();

    f := LLVMGetNamedFunction(module, fname);

    if (f)  v_return(true);

    ft_ = v_type_get_llvm_type(ft);

    f := LLVMAddFunction(module, fname, ft_);

    v_return(true);
}


//---------------------------------------------------------------------
intrinsic_p1_t = (vis: voidc_visitor_ptr, aux: *void,
                  ast: v_ast_expr_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef
                 ) -> void;

intrinsic_p2_t = (vis: voidc_visitor_ptr, aux: *void,
                  ast: v_ast_expr_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef,
                  t1: v_type_ptr, v1: LLVMValueRef
                 ) -> void;


intrinsic_p12_t = (vis: voidc_visitor_ptr, aux: *void,
                   ast: v_ast_expr_ptr,
                   t0:  v_type_ptr, v0:  LLVMValueRef,
                   t1: &v_type_ptr, v1: &LLVMValueRef
                  ) -> void;


//---------------------------------------------------------------------
op_assign_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      args: v_ast_expr_list_ptr, count: int) -> void
{
    ast = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_list_get_items(args, 0, ast, 2);

    tt = v_get_result_type();

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((ast+0 : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    q = op_table[(aux: int)][2];    //- Quark

    builder = v_target_get_builder();

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    f:  &LLVMValueRef := 0;
    ft: &v_type_ptr   := 0;

    if (lookup_function_dict(vis, q, t0, void_fun, void_aux, f, ft))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, ast, t0, v0);
        }
        else
        {
            val: &LLVMValueRef[2] := {v0};

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[1]);

            v_ast_accept_visitor((ast+1 : v_ast_base_ptr), vis);

            val[1] := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, f, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    e0 = v_type_refptr_get_element_type(t0);

    switch((aux: int))
    {
    case id_infix_add_assign:
    case id_infix_sub_assign:

        if (v_type_is_pointer(e0))
        {
            v_set_result_type(intptr_t);

            v_break();
        }

        //- Fallthrough

    default:

        v_set_result_type(e0);
    }

    v_ast_accept_visitor((ast+1 : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    compile: &*((v_type_ptr, LLVMValueRef, LLVMValueRef) -> LLVMValueRef) := 0;

    switch((aux: int))
    {
    case id_infix_add_assign:   compile := voidc_internal_compile_add_helper;   v_break();
    case id_infix_sub_assign:   compile := voidc_internal_compile_sub_helper;   v_break();
    case id_infix_mul_assign:   compile := voidc_internal_compile_mul_helper;   v_break();
    case id_infix_div_assign:   compile := voidc_internal_compile_div_helper;   v_break();
    case id_infix_rem_assign:   compile := voidc_internal_compile_rem_helper;   v_break();
    case id_infix_shl_assign:   compile := voidc_internal_compile_shl_helper;   v_break();
    case id_infix_shr_assign:   compile := voidc_internal_compile_shr_helper;   v_break();
    case id_infix_and_assign:   compile := voidc_internal_compile_and_helper;   v_break();
    case id_infix_xor_assign:   compile := voidc_internal_compile_xor_helper;   v_break();
    case id_infix_or_assign:    compile := voidc_internal_compile_or_helper;    v_break();
    }


    vr: &LLVMValueRef := v1;

    if (compile)
    {
        v = LLVMBuildLoad2(builder, v_type_get_llvm_type(e0), v0, "");

        vr := compile(e0, v, v1);
    }
    else
    {
        if (v_type_is_pointer(v_type_get_scalar_type(e0)))      //- WTF ?!?!?!?
        {
            vr := v_convert_to_type(t1, v1, e0);
        }
    }

    LLVMBuildStore(builder, vr, v0);


    v_set_result_type(tt);

    v_adopt_result(t0, v0);
}


//---------------------------------------------------------------------
op_binary_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      args: v_ast_expr_list_ptr, count: int) -> void
{
    ast = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_list_get_items(args, 0, ast, 2);

    tt = v_get_result_type();

    //- First argument

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((ast+0 : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    q0 = op_table[(aux: int)][2];       //- Quark (left)

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    f:  &LLVMValueRef := 0;
    ft: &v_type_ptr   := 0;

    builder = v_target_get_builder();

    if (lookup_function_dict(vis, q0, t0, void_fun, void_aux, f, ft))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, ast, t0, v0);
        }
        else
        {
            val: &LLVMValueRef[2] := {v0};

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[1]);

            v_ast_accept_visitor((ast+1 : v_ast_base_ptr), vis);

            val[1] := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, f, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Second argument

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((ast+1 : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    q1 = op_table[(aux: int)][3];       //- Quark (right)

    if (lookup_function_dict(vis, q1, t1, void_fun, void_aux, f, ft))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p2_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, ast, t0, v0, t1, v1);
        }
        else
        {
            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[0]);

            v_adopt_result(t0, v0);

            val: &LLVMValueRef[2] := {v_get_result_value(), v1};

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, f, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Default treatment...

    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t0, v0);

    t0: &v_type_ptr   := v_get_result_type();
    v0: &LLVMValueRef := v_get_result_value();

    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t1, v1);

    t1: &v_type_ptr   := v_get_result_type();
    v1: &LLVMValueRef := v_get_result_value();

    {   compile: &*((&v_type_ptr, &LLVMValueRef, &v_type_ptr, &LLVMValueRef) -> LLVMValueRef) := 0;

        switch((aux: int))
        {
        case id_infix_add:  compile := voidc_internal_compile_infix_add_helper; v_break();
        case id_infix_sub:  compile := voidc_internal_compile_infix_sub_helper; v_break();
        }

        if (compile)
        {
            v = compile(t0, v0, t1, v1);

            v_set_result_type(tt);

            v_adopt_result(t0, v);

            v_return();
        }
    }

    compile: &*((v_type_ptr, LLVMValueRef, LLVMValueRef) -> LLVMValueRef) := 0;

    switch((aux: int))
    {
    case id_infix_mul:  compile := voidc_internal_compile_mul_helper;   v_break();
    case id_infix_div:  compile := voidc_internal_compile_div_helper;   v_break();
    case id_infix_rem:  compile := voidc_internal_compile_rem_helper;   v_break();
    case id_infix_shl:  compile := voidc_internal_compile_shl_helper;   v_break();
    case id_infix_shr:  compile := voidc_internal_compile_shr_helper;   v_break();
    case id_infix_and:  compile := voidc_internal_compile_and_helper;   v_break();
    case id_infix_xor:  compile := voidc_internal_compile_xor_helper;   v_break();
    case id_infix_or:   compile := voidc_internal_compile_or_helper;    v_break();
    }

    voidc_internal_convert_to_common_type_helper(t0, v0, t1, v1);

    v = compile(t0, v0, v1);

    v_set_result_type(tt);

    v_adopt_result(t0, v);
}


//---------------------------------------------------------------------
strcmp: (*const char, *const char) -> int;
strncmp: (*const char, *const char, size_t) -> int;

check_relation: (arg: v_ast_base_ptr, lhs: v_ast_base_ptr, rhs: v_ast_base_ptr) -> int
{
    get_tag = v_ast_base_get_visitor_method_tag;

    if (get_tag(arg) != expr_call_tag)  v_return(0);

    arg = (arg: v_ast_expr_ptr);

    etmp = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_expr_call_get_fun_expr(arg, etmp);

    if (get_tag((etmp: v_ast_base_ptr)) != expr_identifier_tag)  v_return(0);

    name = v_ast_expr_identifier_get_name(etmp);

    if (strncmp(name, "v.op_infix_", 11))  v_return(0);

    rk: &int := v_undef();

    block
    {
        suffix = name + 11;

        if (strcmp(suffix, "lt") == 0)  { rk := id_infix_lt; v_break(); }
        if (strcmp(suffix, "le") == 0)  { rk := id_infix_le; v_break(); }
        if (strcmp(suffix, "gt") == 0)  { rk := id_infix_gt; v_break(); }
        if (strcmp(suffix, "ge") == 0)  { rk := id_infix_ge; v_break(); }
        if (strcmp(suffix, "eq") == 0)  { rk := id_infix_eq; v_break(); }
        if (strcmp(suffix, "ne") == 0)  { rk := id_infix_ne; v_break(); }

        v_return(0);
    }

    if (lhs) ;
    else if (rhs) ;
    else
    {
        v_return(rk);
    }

    lst = v_alloca(v_ast_opaque_expr_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_ast_expr_call_get_arg_list(arg, lst);

    if (lhs)  v_list_get_items(lst, 0, (lhs: v_ast_expr_ptr));
    if (rhs)  v_list_get_items(lst, 1, (rhs: v_ast_expr_ptr));

    v_return(rk);
}

//---------------------------------------------------------------------
op_relation_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                        args: v_ast_expr_list_ptr, count: int) -> void
{
    N: &int := 2;

    {   ast = v_alloca(v_ast_opaque_base_sptr);
        v_initialize(ast);
        defer v_terminate(ast);

        v_list_get_items(args, 0, (ast: v_ast_expr_ptr));

        while(check_relation(ast, ast, 0)) ++N;
    }

    ast = v_malloc(v_ast_opaque_base_sptr, N);
    v_initialize(ast, N);
    defer
    {
        v_terminate(ast, N);
        v_mfree(ast);
    }

    Nm1 = N - 1;

    rel = v_malloc(int, Nm1);
    defer v_mfree(rel);

    {   i = N - 2;

        ast_i: &v_ast_base_ptr := ast + i;
        rel_i: &*int           := rel + i;

        v_list_get_items(args, 0, (ast_i: v_ast_expr_ptr), 2);

        *rel_i := (aux: int);

        while(ast_i1 = ast_i-1, rk = check_relation(ast_i, ast_i1, ast_i))
        {
            ast_i := ast_i1;
            rel_i := rel_i - 1;

            *rel_i := rk;
        }
    }


    tt = v_get_result_type();

    builder = v_target_get_builder();

    cur_b = LLVMGetInsertBlock(builder);

    cur_f = LLVMGetBasicBlockParent(cur_b);

    cmp_result_v: &LLVMValueRef := 0;

    branch_if_false_b: &LLVMBasicBlockRef := 0;

    _bool = v_find_type("bool");

    bool_ = v_type_get_llvm_type(_bool);

    if (N != 2)
    {
        cmp_result_v := LLVMBuildAlloca(builder, bool_, "");

        LLVMBuildStore(builder, LLVMConstNull(bool_), cmp_result_v);

        branch_if_false_b := LLVMAppendBasicBlock(cur_f, "branch_if_false_b");
    }


    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(ast+0, vis);

    typ: &v_type_ptr   := v_get_result_type();
    val: &LLVMValueRef := v_get_result_value();

    t0: &v_type_ptr   := v_undef();
    v0: &LLVMValueRef := v_undef();
    t1: &v_type_ptr   := v_undef();
    v1: &LLVMValueRef := v_undef();

    r: &LLVMValueRef := v_undef();

    for (i: &int := 0; i < Nm1; ++i)
    {
        r := 0;

        rel_i = rel[i];

        ast_i  = ast + i;
        ast_i1 = ast_i + 1;

        //- First argument

        t0 := typ;
        v0 := val;

        q0 = op_table[(aux: int)][2];       //- Quark (left)

        void_fun: &*void := 0;
        void_aux: &*void := 0;

        f:  &LLVMValueRef := 0;
        ft: &v_type_ptr   := 0;

        if (lookup_function_dict(vis, q0, typ, void_fun, void_aux, f, ft))
        {
            //- Got overloading!

            if (fun = (void_fun: *intrinsic_p12_t))
            {
                v_set_result_type(tt);      //- Sic !?!

                fun(vis, void_aux, (ast_i: v_ast_expr_ptr), t0, v0, t1, v1);
            }
            else
            {
                vv: &LLVMValueRef[2] := {v0};

                fpar = v_type_function_get_param_types(ft);

                v_set_result_type(fpar[1]);

                v_ast_accept_visitor(ast_i1, vis);

                t1 := v_get_result_type();
                v1 := v_get_result_value();

                vv[1] := v1;

                ft_ = v_type_get_llvm_type(ft);

                vr = LLVMBuildCall2(builder, ft_, f, &vv[0], 2, "");

                v_set_result_type(tt);      //- Sic !?!

                v_adopt_result(v_type_function_get_return_type(ft), vr);
            }

            r := v_get_result_value();
        }
        else
        {
            //- Second argument

            v_set_result_type(INVIOLABLE_TAG);

            v_ast_accept_visitor(ast_i1, vis);

            t1 := v_get_result_type();
            v1 := v_get_result_value();

            q1 = op_table[(aux: int)][3];       //- Quark (right)

            if (lookup_function_dict(vis, q1, t1, void_fun, void_aux, f, ft))
            {
                //- Got overloading!

                if (fun = (void_fun: *intrinsic_p2_t))
                {
                    v_set_result_type(tt);      //- Sic !?!

                    fun(vis, void_aux, (ast_i: v_ast_expr_ptr), t0, v0, t1, v1);
                }
                else
                {
                    fpar = v_type_function_get_param_types(ft);

                    v_set_result_type(fpar[0]);

                    v_adopt_result(t0, v0);

                    vv: &LLVMValueRef[2] := {v_get_result_value(), v1};

                    ft_ = v_type_get_llvm_type(ft);

                    vr = LLVMBuildCall2(builder, ft_, f, &vv[0], 2, "");

                    v_set_result_type(tt);      //- Sic !?!

                    v_adopt_result(v_type_function_get_return_type(ft), vr);
                }

                r := v_get_result_value();
            }
        }

        typ := t1;
        val := v1;

        if (!r)
        {
            //- Default treatment...

            v_set_result_type(UNREFERENCE_TAG);

            v_adopt_result(t0, v0);

            t0 := v_get_result_type();
            v0 := v_get_result_value();

            v_set_result_type(UNREFERENCE_TAG);

            v_adopt_result(t1, v1);

            t1 := v_get_result_type();
            v1 := v_get_result_value();

            voidc_internal_convert_to_common_type_helper(t0, v0, t1, v1);


            st = v_type_get_scalar_type(t0);


            if (v_type_is_floating_point(st))
            {
                opc: &LLVMRealPredicate := v_undef();

                switch(rel_i)
                {
                case id_infix_eq: opc := LLVMRealOEQ; v_break();    //- 'O' ?...
                case id_infix_ne: opc := LLVMRealUNE; v_break();    //- 'U' ?!?!?..
                case id_infix_lt: opc := LLVMRealOLT; v_break();    //- 'O' ?...
                case id_infix_le: opc := LLVMRealOLE; v_break();    //- 'O' ?...
                case id_infix_gt: opc := LLVMRealOGT; v_break();    //- 'O' ?...
                case id_infix_ge: opc := LLVMRealOGE; v_break();    //- 'O' ?...
                }

                r := LLVMBuildFCmp(builder, opc, v0, v1, "");
            }
            else
            {
                opc: &LLVMIntPredicate := v_undef();

                s: &bool := false;

                if (v_type_is_integer(st))  s := v_type_integer_is_signed(st);

                switch(rel_i)
                {
                case id_infix_eq: opc := LLVMIntEQ; v_break();
                case id_infix_ne: opc := LLVMIntNE; v_break();

                case id_infix_lt: if (s)  opc := LLVMIntSLT;  else  opc := LLVMIntULT;  v_break();
                case id_infix_le: if (s)  opc := LLVMIntSLE;  else  opc := LLVMIntULE;  v_break();
                case id_infix_gt: if (s)  opc := LLVMIntSGT;  else  opc := LLVMIntUGT;  v_break();
                case id_infix_ge: if (s)  opc := LLVMIntSGE;  else  opc := LLVMIntUGE;  v_break();
                }

                r := LLVMBuildICmp(builder, opc, v0, v1, "");
            }
        }

        if (branch_if_false_b)
        {
            if (i < N-2)
            {
                branch_if_true_b = LLVMAppendBasicBlock(cur_f, "branch_if_true_b");

                LLVMBuildCondBr(builder, r, branch_if_true_b, branch_if_false_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_true_b);
            }
            else        //- Last ...
            {
                LLVMBuildStore(builder, r, cmp_result_v);

                LLVMBuildBr(builder, branch_if_false_b);

                cur_b = LLVMGetInsertBlock(builder);

                LLVMMoveBasicBlockAfter(branch_if_false_b, cur_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_false_b);

                r := LLVMBuildLoad2(builder, bool_, cmp_result_v, "");
            }
        }
    }


    if (v_type_is_vector(t0))
    {
        sz = v_type_vector_get_size(t0);

        if (v_type_vector_is_scalable(t0))
        {
            t0 := v_svector_type(_bool, sz);
        }
        else
        {
            t0 := v_vector_type(_bool, sz);
        }
    }
    else
    {
        t0 := _bool;
    }


    v_set_result_type(tt);

    v_adopt_result(t0, r);
}

























//=====================================================================
{
    v_add_intrinsic("v.op_infix_assign",     op_assign_intrinsic, (id_infix_assign:     *void));
    v_add_intrinsic("v.op_infix_add_assign", op_assign_intrinsic, (id_infix_add_assign: *void));
    v_add_intrinsic("v.op_infix_sub_assign", op_assign_intrinsic, (id_infix_sub_assign: *void));
    v_add_intrinsic("v.op_infix_mul_assign", op_assign_intrinsic, (id_infix_mul_assign: *void));
    v_add_intrinsic("v.op_infix_div_assign", op_assign_intrinsic, (id_infix_div_assign: *void));
    v_add_intrinsic("v.op_infix_rem_assign", op_assign_intrinsic, (id_infix_rem_assign: *void));
    v_add_intrinsic("v.op_infix_shl_assign", op_assign_intrinsic, (id_infix_shl_assign: *void));
    v_add_intrinsic("v.op_infix_shr_assign", op_assign_intrinsic, (id_infix_shr_assign: *void));
    v_add_intrinsic("v.op_infix_and_assign", op_assign_intrinsic, (id_infix_and_assign: *void));
    v_add_intrinsic("v.op_infix_xor_assign", op_assign_intrinsic, (id_infix_xor_assign: *void));
    v_add_intrinsic("v.op_infix_or_assign",  op_assign_intrinsic, (id_infix_or_assign:  *void));

    v_add_intrinsic("v.op_infix_add", op_binary_intrinsic, (id_infix_add: *void));
    v_add_intrinsic("v.op_infix_sub", op_binary_intrinsic, (id_infix_sub: *void));
    v_add_intrinsic("v.op_infix_mul", op_binary_intrinsic, (id_infix_mul: *void));
    v_add_intrinsic("v.op_infix_div", op_binary_intrinsic, (id_infix_div: *void));
    v_add_intrinsic("v.op_infix_rem", op_binary_intrinsic, (id_infix_rem: *void));
    v_add_intrinsic("v.op_infix_shl", op_binary_intrinsic, (id_infix_shl: *void));
    v_add_intrinsic("v.op_infix_shr", op_binary_intrinsic, (id_infix_shr: *void));
    v_add_intrinsic("v.op_infix_and", op_binary_intrinsic, (id_infix_and: *void));
    v_add_intrinsic("v.op_infix_xor", op_binary_intrinsic, (id_infix_xor: *void));
    v_add_intrinsic("v.op_infix_or",  op_binary_intrinsic, (id_infix_or:  *void));

    v_add_intrinsic("v.op_infix_eq", op_relation_intrinsic, (id_infix_eq: *void));
    v_add_intrinsic("v.op_infix_ne", op_relation_intrinsic, (id_infix_ne: *void));
    v_add_intrinsic("v.op_infix_lt", op_relation_intrinsic, (id_infix_lt: *void));
    v_add_intrinsic("v.op_infix_le", op_relation_intrinsic, (id_infix_le: *void));
    v_add_intrinsic("v.op_infix_gt", op_relation_intrinsic, (id_infix_gt: *void));
    v_add_intrinsic("v.op_infix_ge", op_relation_intrinsic, (id_infix_ge: *void));

    //- ...

}



//---------------------------------------------------------------------




//=====================================================================
double = float(64);

complex = v_struct("struct.complex")
(
    double,     //- real
    double      //- imag
);


//---------------------------------------------------------------------
complex_add_assign: (a: &complex, b: complex) -> &complex
{
    a := { a[0]+b[0], a[1]+b[1] };

    v_return(a);
}

complex_sub_assign: (a: &complex, b: complex) -> &complex
{
    a := { a[0]-b[0], a[1]-b[1] };

    v_return(a);
}

complex_mul_assign: (a: &complex, b: complex) -> &complex
{
    a := { a[0]*b[0] - a[1]*b[1], a[0]*b[1] + a[1]*b[0] };

    v_return(a);
}

complex_div_assign: (a: &complex, b: complex) -> &complex
{
    d = b[0]*b[0] + b[1]*b[1];

    a := { (a[0]*b[0] + a[1]*b[1])/d, (a[1]*b[0] - a[0]*b[1])/d };

    v_return(a);
}

//---------------------------------------------------------------------
{
    complex_ref = v_reference_type(complex, 0);

    v_util_function_dict_set(v_quark_from_string("op_infix_add_assign"), complex_ref, "complex_add_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_sub_assign"), complex_ref, "complex_sub_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_mul_assign"), complex_ref, "complex_mul_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_div_assign"), complex_ref, "complex_div_assign");
}


//---------------------------------------------------------------------
complex_add: (a: complex, b: complex) -> complex
{
    v_return({ a[0]+b[0], a[1]+b[1] });
}

complex_sub: (a: complex, b: complex) -> complex
{
    v_return({ a[0]-b[0], a[1]-b[1] });
}

complex_mul: (a: complex, b: complex) -> complex
{
    v_return({ a[0]*b[0] - a[1]*b[1], a[0]*b[1] + a[1]*b[0] });
}

complex_div: (a: complex, b: complex) -> complex
{
    d = b[0]*b[0] + b[1]*b[1];

    v_return({ (a[0]*b[0] + a[1]*b[1])/d, (a[1]*b[0] - a[0]*b[1])/d });
}

//---------------------------------------------------------------------
{
    v_util_function_dict_set(v_quark_from_string("op_infix_add"), complex, "complex_add");
    v_util_function_dict_set(v_quark_from_string("op_infix_sub"), complex, "complex_sub");
    v_util_function_dict_set(v_quark_from_string("op_infix_mul"), complex, "complex_mul");
    v_util_function_dict_set(v_quark_from_string("op_infix_div"), complex, "complex_div");
}


//---------------------------------------------------------------------
sin: (double) -> double;
cos: (double) -> double;

M_PI = 3.14159265358979323846264338327950288419716939937510582;


//---------------------------------------------------------------------
U: complex = { 1, 0 };
I: complex = { 0, 1 };

//{ v_debug_print_module(1); }
{
    alpha = M_PI / 180;

    a: complex = {cos(alpha), sin(alpha)};

    z: &complex := U;

    for (i: &int := 0; i <= 360; ++i)
    {
//      printf("(%g, %g)\n", z[0], z[1]);

        z /= a;
    }
}












//=====================================================================
double = float(64);

number = v_struct("struct.number")
(
    double
);


//---------------------------------------------------------------------
number_add_assign: (a: &number, b: number) -> &number
{
    v_return(a := {a[0] + b[0]});
}

number_sub_assign: (a: &number, b: number) -> &number
{
    v_return(a := {a[0] - b[0]});
}

number_mul_assign: (a: &number, b: number) -> &number
{
    v_return(a := {a[0] * b[0]});
}

number_div_assign: (a: &number, b: number) -> &number
{
    v_return(a := {a[0] / b[0]});
}

//---------------------------------------------------------------------
{
    number_ref = v_reference_type(number, 0);

    v_util_function_dict_set(v_quark_from_string("op_infix_add_assign"), number_ref, "number_add_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_sub_assign"), number_ref, "number_sub_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_mul_assign"), number_ref, "number_mul_assign");
    v_util_function_dict_set(v_quark_from_string("op_infix_div_assign"), number_ref, "number_div_assign");
}


//---------------------------------------------------------------------
number_add: (a: number, b: number) -> number
{
    v_return({a[0] + b[0]});
}

number_sub: (a: number, b: number) -> number
{
    v_return({a[0] - b[0]});
}

number_mul: (a: number, b: number) -> number
{
    v_return({a[0] * b[0]});
}

number_div: (a: number, b: number) -> number
{
    v_return({a[0] / b[0]});
}

//---------------------------------------------------------------------
{
    v_util_function_dict_set(v_quark_from_string("op_infix_add"), number, "number_add");
    v_util_function_dict_set(v_quark_from_string("op_infix_sub"), number, "number_sub");
    v_util_function_dict_set(v_quark_from_string("op_infix_mul"), number, "number_mul");
    v_util_function_dict_set(v_quark_from_string("op_infix_div"), number, "number_div");
}


//---------------------------------------------------------------------
number_eq: (a: number, b: number) -> bool   { v_return(a[0] == b[0]); }
number_ne: (a: number, b: number) -> bool   { v_return(a[0] != b[0]); }
number_lt: (a: number, b: number) -> bool   { v_return(a[0] <  b[0]); }
number_le: (a: number, b: number) -> bool   { v_return(a[0] <= b[0]); }
number_gt: (a: number, b: number) -> bool   { v_return(a[0] >  b[0]); }
number_ge: (a: number, b: number) -> bool   { v_return(a[0] >= b[0]); }

number_ref_eq: (a: &number, b: number) -> bool   { v_return(a[0] == b[0]); }
number_ref_ne: (a: &number, b: number) -> bool   { v_return(a[0] != b[0]); }
number_ref_lt: (a: &number, b: number) -> bool   { v_return(a[0] <  b[0]); }
number_ref_le: (a: &number, b: number) -> bool   { v_return(a[0] <= b[0]); }
number_ref_gt: (a: &number, b: number) -> bool   { v_return(a[0] >  b[0]); }
number_ref_ge: (a: &number, b: number) -> bool   { v_return(a[0] >= b[0]); }

//---------------------------------------------------------------------
{
    v_util_function_dict_set(v_quark_from_string("op_infix_eq"), number, "number_eq");
    v_util_function_dict_set(v_quark_from_string("op_infix_ne"), number, "number_ne");
    v_util_function_dict_set(v_quark_from_string("op_infix_lt"), number, "number_lt");
    v_util_function_dict_set(v_quark_from_string("op_infix_le"), number, "number_le");
    v_util_function_dict_set(v_quark_from_string("op_infix_gt"), number, "number_gt");
    v_util_function_dict_set(v_quark_from_string("op_infix_ge"), number, "number_ge");

    number_ref = v_reference_type(number, 0);

    v_util_function_dict_set(v_quark_from_string("op_infix_eq"), number_ref, "number_ref_eq");
    v_util_function_dict_set(v_quark_from_string("op_infix_ne"), number_ref, "number_ref_ne");
    v_util_function_dict_set(v_quark_from_string("op_infix_lt"), number_ref, "number_ref_lt");
    v_util_function_dict_set(v_quark_from_string("op_infix_le"), number_ref, "number_ref_le");
    v_util_function_dict_set(v_quark_from_string("op_infix_gt"), number_ref, "number_ref_gt");
    v_util_function_dict_set(v_quark_from_string("op_infix_ge"), number_ref, "number_ref_ge");
}


//---------------------------------------------------------------------
{ v_debug_print_module(1); }
{
    a: number = { 0.1 };
    b: number = { 0.9 };

    printf("a == b : %d\n", (a == b : int));
    printf("a != b : %d\n", (a != b : int));
    printf("a <  b : %d\n", (a <  b : int));
    printf("a <= b : %d\n", (a <= b : int));
    printf("a >  b : %d\n", (a >  b : int));
    printf("a >= b : %d\n", (a >= b : int));

    v: &number := { 0 };

    for (i: &int := 0; i < 12; ++i)
    {
        r = a < v < b;

        printf("a < { %g } < b : %d\n", v[0], (r : int));

        v += a;
    }
}






