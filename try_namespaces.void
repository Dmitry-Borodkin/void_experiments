{ v_import("mainline.void"); }
{ v_enable_mainline(); }

//---------------------------------------------------------------------
printf: (*const char, ...) ~> int;


//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(99); }


//=====================================================================
struct v_static_namespace_t;        //- Opaque...


//---------------------------------------------------------------------
struct v_namespace_t
{
    prefix: v_std_string_t;         //- ...

    list:   v_util_list_t;          //- Names in "textual" order
    map:    v_util_map_t;           //- Names -> "global" names...

    used:   v_util_list_t;          //- Used namespaces
};


//---------------------------------------------------------------------
(v_initialize(_)): (p: *v_namespace_t, n: size_t) ~> void
{
    for (i: &size_t := 0; i < n; ++i)
    {
        p_i = p[i];

        v_initialize(&p_i.prefix);
        v_initialize(&p_i.list);
        v_initialize(&p_i.map);
        v_initialize(&p_i.used);

        v_make_list_nil(&p_i.list);
        v_make_map(&p_i.map);
        v_make_list_nil(&p_i.used);
    }
}

(v_terminate(_)): (p: *v_namespace_t, n: size_t) ~> void  =  derive;

(v_copy(_)): (d: *v_namespace_t, s: *const v_namespace_t, n: size_t) ~> void  =  derive;        //- ?

//---------------------------------------------------------------------
//private
namespace_cleaner: (void_ctx: *void) ~> void
{
    delete (void_ctx: *v_namespace_t);
}


//=====================================================================
{
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("unit_namespace_open_q", q_ref, q("unit_namespace_open"));
    v_add_symbol("unit_defn_close_q",     q_ref, q("unit_defn_close"));
    v_add_symbol("unit_defn_using_q",     q_ref, q("unit_defn_using"));
    v_add_symbol("q_stmt_using",          q_ref, q("v.stmt_using"));

    v_add_symbol("q_op_postfix_dot", q_ref, q("v.op_postfix_dot"));

    v_add_symbol("q_current_namespace_list",  q_ref, q("v.current_namespace_list"));
    v_add_symbol("q_current_namespace_stack", q_ref, q("v.current_namespace_stack"));
    v_add_symbol("q_current_namespace_used",  q_ref, q("v.current_namespace_used"));
}


//---------------------------------------------------------------------












//---------------------------------------------------------------------
//- Grammar actions ...
//---------------------------------------------------------------------
//private
mk_unit_namespace_open_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    expr = v_std_any_get_pointer(v_ast_expr_t, any);

    nsid: &v_ast_expr_t := {};

    if (expr)   v_copy(&nsid, expr);

    list: &v_ast_generic_list_t := {};

    v_make_list(&list, unit_namespace_open_q, &nsid);

    v_std_any_set_pointer(ret, (&list: *v_ast_base_t));
}

//---------------------------------------------------------------------
//private
mk_unit_defn_close_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    list: &v_ast_generic_list_t := {};

    v_make_list_nil(&list, unit_defn_close_q);

    v_std_any_set_pointer(ret, (&list: *v_ast_base_t));
}

//---------------------------------------------------------------------
//private
mk_using_stmt_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    flag = v_std_any_get_value(intptr_t, any+0);
    expr = v_std_any_get_pointer(v_ast_expr_t, any+1);

    elst: &v_ast_expr_list_t := {};

    eflg: &v_ast_expr_t := {};

    v_ast_make_expr_integer(&eflg, flag);

    v_make_list(&elst, &eflg);

    v_list_append(&elst, &elst, expr);

    v_std_any_set_pointer(ret, &elst);
}

//---------------------------------------------------------------------
//private
mk_unit_defn_using_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    elst = v_std_any_get_pointer(v_ast_expr_list_t, any);

    list: &v_ast_generic_list_t := {};

    v_make_list(&list, unit_defn_using_q, elst);

    v_std_any_set_pointer(ret, (&list: *v_ast_base_t));
}

//---------------------------------------------------------------------
//private
mk_stmt_using_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    elst = v_std_any_get_pointer(v_ast_expr_list_t, any);

    expr: &v_ast_expr_t := {};

    v_ast_make_expr_identifier_q(&expr, q_stmt_using);

    v_ast_make_expr_call(&expr, &expr, elst);

    stmt: &v_ast_stmt_t := {};

    v_ast_make_stmt(&stmt, "", &expr);

    v_std_any_set_pointer(ret, &stmt);
}


//---------------------------------------------------------------------
//- Compile methods ...
//---------------------------------------------------------------------
dump_namespaces: () ~> void
{
printf("dump_namespaces start\n");
defer printf("dump_namespaces stop\n");

    anss = v_std_any_get_pointer(v_util_list_t, v_get_property_q(q_current_namespace_stack));

    s = v_list_get_size(anss);

    printf("s - %d\n", (s: int));

    for (i: &int := 0; i < s; ++i)
    {
        p = v_list_get_item(anss, i);

        q = v_std_any_get_pointer(v_util_list_t, p);

        s = v_list_get_size(q);

        printf("%d\n", (s: int));

        for (j: &int := 0; j < s; ++j)
        {
            r = v_list_get_item(q, j);

            ns = (v_std_any_get_value(intptr_t, r) : *v_namespace_t);

            printf("  [%s] %zd %zd\n", v_std_string_get(&ns->prefix), v_list_get_size(&ns->list), v_map_get_size(&ns->map));
        }
    }

    ansl = v_std_any_get_pointer(v_util_list_t, v_get_property_q(q_current_namespace_list));

    s = v_list_get_size(ansl);

    printf("l - %d\n", (s: int));

    for (j: &int := 0; j < s; ++j)
    {
        r = v_list_get_item(ansl, j);

        ns = (v_std_any_get_value(intptr_t, r) : *v_namespace_t);

        printf("  [%s] %zd %zd\n", v_std_string_get(&ns->prefix), v_list_get_size(&ns->list), v_map_get_size(&ns->map));
    }
}


//---------------------------------------------------------------------
//private
compile_unit_namespace_open: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
printf("compile_unit_namespace_open start\n");
defer printf("compile_unit_namespace_open stop\n");

dump_namespaces();
defer dump_namespaces();

    list = (self: *v_ast_generic_list_t);
    nsid = (v_list_get_item(list, 0) : *v_ast_expr_t);

    v_assert(!v_empty(nsid));

    N: &int := 0;

    for (e: &*v_ast_expr_t := nsid; ; ++N)
    {
        q = v_ast_base_get_visitor_method_tag(e);
        if (q != v_ast_expr_call_visitor_method_tag)  v_break();

        f = v_ast_expr_call_get_fun_expr(e);

        q = v_ast_base_get_visitor_method_tag(f);
        if (q != v_ast_expr_identifier_visitor_method_tag)  v_break();

        q = v_ast_expr_identifier_get_name_q(f);
        if (q != q_op_postfix_dot)  v_break();

        args = v_ast_expr_call_get_arg_list(e);

        e := v_list_get_item(args, 1);
    }

    etmp: &*v_ast_expr_t := nsid;

    qs = new v_quark_t[N+1];
    defer delete[] qs;

    for (i: &int := 0; i < N; ++i)
    {
        args = v_ast_expr_call_get_arg_list(etmp);

        op = v_list_get_item(args, 0);

        void_obj = v_ast_generic_get_object(op);

        obj = *(void_obj: *v_ast_operator_unary_t);

        pay = (&obj[2] : *v_ast_generic_list_t);

        expr = (v_list_get_item(pay, 0) : *v_ast_expr_t);

        qs[N-i] := v_ast_expr_identifier_get_name_q(expr);

        etmp := v_list_get_item(args, 1);
    }

    v_assert(v_ast_base_get_visitor_method_tag(etmp) == v_ast_expr_identifier_visitor_method_tag);      //- ?

    qs[0] := v_ast_expr_identifier_get_name_q(etmp);

    {   anss = v_std_any_get_pointer(v_util_list_t, v_get_property_q(q_current_namespace_stack));

        v_list_append(anss, anss, v_get_property_q(q_current_namespace_list));
    }

    for (i: &int := 0; i <= N; ++i)
    {
        qns = v_check_alias_q(qs[i]);

//      v_assert(v_find_constant_type(qns) == v_static_namespace_t);

        ns: &*v_namespace_t := (v_find_constant_value_q(qns) : *v_namespace_t);

        if (!ns)
        {
            ns := new v_namespace_t;

            v_add_local_cleaner(namespace_cleaner, ns);

            pref = &ns->prefix;

            a = v_get_property_q(q_current_namespace_list);

            l = v_std_any_get_pointer(v_util_list_t, a);

            if (s = v_list_get_size(l))
            {
                c = v_list_get_item(l, s-1);

                cur_ns = (v_std_any_get_value(intptr_t, c): *v_namespace_t);

                v_copy(pref, &cur_ns->prefix);

                v_std_string_append_char(pref, ' ');

                v_std_string_append(pref, v_quark_to_string(qns));

                sstr: &v_std_string_t := {};

                v_std_string_set(&sstr, "v__");

                voidc_internal_std_string_append_mangle(&sstr, pref);

                qm = v_quark_from_string(v_std_string_get(&sstr));

                a: &v_std_any_t := {};

                v_std_any_set_value(&a, qns);

                v_list_append(&cur_ns->list, &cur_ns->list, &a);

                v_std_any_set_value(&a, qm);

                v_map_insert(&cur_ns->map, &cur_ns->map, (qns: intptr_t), &a);
            }
            else
            {
                v_std_string_set(pref, v_quark_to_string(qns));
            }

            v_add_constant_q(qns, v_static_namespace_t, (ns: LLVMValueRef));
        }

printf(" %s\n", v_std_string_get(&ns->prefix));

        ansl = v_std_any_get_pointer(v_util_list_t, v_get_property_q(q_current_namespace_list));

        a: &v_std_any_t := {};

        v_std_any_set_value(&a, (ns: intptr_t));

        v_list_append(ansl, ansl, &a);


    }


}

//---------------------------------------------------------------------
//private
compile_unit_defn_close: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
printf("compile_unit_defn_close start\n");
defer printf("compile_unit_defn_close stop\n");

dump_namespaces();
defer dump_namespaces();

    anss = v_std_any_get_pointer(v_util_list_t, v_get_property_q(q_current_namespace_stack));

    i = v_list_get_size(anss) - 1;

    a = v_get_property_q(q_current_namespace_list);

    v_copy(a, v_list_get_item(anss, i));

    v_list_erase(anss, anss, i, 1);
}

//---------------------------------------------------------------------
//private
compile_unit_defn_using: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
printf("compile_unit_defn_using start\n");
defer printf("compile_unit_defn_using stop\n");


}

//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
//private
v_stmt_using_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
printf("v_stmt_using_intrinsic start\n");
defer printf("v_stmt_using_intrinsic stop\n");


}

//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
//private
lookup_in_namespace: (cache: *v_util_map_t, ns: *v_namespace_t, q: v_quark_t) ~> v_quark_t
{
    if (v_map_find(cache, (ns: intptr_t)))  v_return(0);

    if (a = v_map_find(&ns->map, (q: intptr_t)))
    {
        v_return(v_std_any_get_value(v_quark_t, a));
    }

    a: &v_std_any_t := {};

    v_map_insert(cache, cache, (ns: intptr_t), &a);

    s = v_list_get_size(&ns->used);

    for (i: &int := (s-1 : int); i >= 0; --i)
    {
        r = v_list_get_item(&ns->used, i);

        nsu = (v_std_any_get_value(intptr_t, r) : *v_namespace_t);

        qr = lookup_in_namespace(cache, nsu, q);

        if (qr) v_return(qr);
    }

    v_return(0);
}

//---------------------------------------------------------------------
my_check_alias_ctx_t = struct
{
    fun: *((*void, v_quark_t) ~> v_quark_t);
    aux: *void;
};

//---------------------------------------------------------------------
//private
my_check_alias: (aux: *void, q: v_quark_t) ~> v_quark_t
{
//printf("my_check_alias start %s\n", v_quark_to_string(q));
//defer printf("my_check_alias stop  %s\n", v_quark_to_string(v_get_return_value()));

    cache: &v_util_map_t := {};

    v_make_map(&cache);

    lists: &v_quark_t[2] := { q_current_namespace_list, q_current_namespace_used };

    for (l: &int := 0; l < 2; ++l)
    {
        lst = v_std_any_get_pointer(v_util_list_t, v_get_property_q(lists[l]));

        s = v_list_get_size(lst);

        for (i: &int := (s-1 : int); i >= 0; --i)
        {
            r = v_list_get_item(lst, i);

            ns = (v_std_any_get_value(intptr_t, r) : *v_namespace_t);

            qr = lookup_in_namespace(&cache, ns, q);

            if (qr) v_return(qr);
        }
    }

    ctx = *(aux: *my_check_alias_ctx_t);

    v_return(ctx.fun(ctx.aux, q));
}


//---------------------------------------------------------------------
{
    vis = v_get_compiler();

    voidc_visitor_set_void_method(vis, vis, unit_namespace_open_q, compile_unit_namespace_open, 0);
    voidc_visitor_set_void_method(vis, vis, unit_defn_close_q,     compile_unit_defn_close,     0);
    voidc_visitor_set_void_method(vis, vis, unit_defn_using_q,     compile_unit_defn_using,     0);

    v_add_intrinsic_q(q_stmt_using, v_stmt_using_intrinsic, 0);

    //--------------------------------------------------------------
    {   l: &v_util_list_t := {};

        v_make_list_nil(&l);

        a: &v_std_any_t := {};

        v_std_any_set_pointer(&a, &l);

        v_add_property_q(q_current_namespace_list,  &a);
        v_add_property_q(q_current_namespace_stack, &a);
        v_add_property_q(q_current_namespace_used,  &a);
    }

    //--------------------------------------------------------------
    ctx = v_malloc(my_check_alias_ctx_t);

    free: (*void) ~> void;

    v_add_local_cleaner(free, ctx);

    ctx->fun := v_get_check_alias_hook(&ctx->aux);

    v_set_check_alias_hook(my_check_alias, ctx);


}


//=====================================================================
{
    gr0: &v_peg_grammar_t := {};    gr0 = &gr0;

    v_peg_get_grammar(gr0);

    //--------------------------------------------------------------
    grammar gr0
    {
    actions:
        mk_unit_namespace_open = mk_unit_namespace_open_grammar_action;
        mk_unit_defn_close     = mk_unit_defn_close_grammar_action;
        mk_using_stmt          = mk_using_stmt_grammar_action;
        mk_unit_defn_using     = mk_unit_defn_using_grammar_action;
        mk_stmt_using          = mk_stmt_using_grammar_action;

    parsers:

        unit_namespace_open = "namespace" !ident_cont _ ns:expr? _ '{'   { mk_unit_namespace_open(ns) };

        unit_defn_close = '}'   { mk_unit_defn_close() };

        using_stmt = "using" !ident_cont _ "namespace" !ident_cont _ e:expr _';'    { mk_using_stmt(1, e) }
                   / "using" !ident_cont _ e:expr _';'                              { mk_using_stmt(0, e) }
                   ;

        unit_defn += unit_namespace_open
                   / unit_defn_close
                   / u:using_stmt       { mk_unit_defn_using(u) }
                   ;

        stmt += u:using_stmt    { mk_stmt_using(u) };
    }

    v_peg_set_grammar(gr0);
}


//=====================================================================

namespace qwe.asd.zxc {

namespace a0 {
namespace a1 {

a = 10;

}
}

namespace b0 {
namespace b1 {

b = 100;

}
}

}


//qaz = qwe.asd.zxc;
//
//namespace qaz {

namespace qwe.asd.zxc {

namespace b0 {
namespace b1 {

bb = 200;

}
}

}



//namespace {
//
//using namespace qwe.asd.zxc;
//
//using a0.a1.a;
//
//c = 1000;
//
//}


{
    using namespace qwe.asd.zxc;

    using a0.a1.a;


}



