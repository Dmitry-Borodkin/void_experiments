{ v_import("mainline.void"); }
{ v_enable_mainline(); }

{   v_import("llvm-c/Core.void");
    v_import("llvm-c/Support.void");

    v_import("cstdio.void");
    v_import("type_traits.void");
}

//---------------------------------------------------------------------
{

#if (v_defined(_WIN32))

    libname = v_malloc(char, 1024);
    defer v_free(libname);

    {   p = popen("bash -c \"dlltool -I $(pkg-config --variable=libdir girepository-2.0)/libgirepository-2.0.dll.a\"", "r");
        defer pclose(p);

        fscanf(p, "%1023s", libname);
    }

#else

    libname = "libgirepository-2.0.so";         //- !

#endif

    ok = LLVMLoadLibraryPermanently(libname);

//  printf("ok: %d\n", ok);
}


//---------------------------------------------------------------------
//- <girepository/girepository.h>
//---------------------------------------------------------------------
struct GIRepository;
struct GITypelib;
struct GIBaseInfo;

struct GError;



//---------------------------------------------------------------------
gi_repository_new: () ~> *GIRepository;

g_object_unref: (*void) ~> void;    //- ?

gi_repository_require: (*GIRepository, *const char, *const char, int, **GError) ~> *GITypelib;


gi_typelib_unref: (*GITypelib) ~> void;


gi_repository_get_n_infos: (*GIRepository, *const char) ~> int;

gi_repository_get_info: (*GIRepository, *const char, int) ~> *GIBaseInfo;


gi_base_info_unref: (*GIBaseInfo) ~> void;

gi_base_info_get_name: (*GIBaseInfo) ~> *const char;

gi_base_info_get_namespace: (*GIBaseInfo) ~> *const char;



//---------------------------------------------------------------------
GType = size_t;

#assert (GType == uint(intptr_t.width))

gi_base_info_gt           : &GType := undef;
gi_callable_info_gt       : &GType := undef;
gi_function_info_gt       : &GType := undef;
gi_callback_info_gt       : &GType := undef;
gi_registered_type_info_gt: &GType := undef;
gi_struct_info_gt         : &GType := undef;
gi_union_info_gt          : &GType := undef;
gi_enum_info_gt           : &GType := undef;
gi_flags_info_gt          : &GType := undef;
gi_object_info_gt         : &GType := undef;
gi_interface_info_gt      : &GType := undef;
gi_constant_info_gt       : &GType := undef;
gi_value_info_gt          : &GType := undef;
gi_signal_info_gt         : &GType := undef;
gi_vfunc_info_gt          : &GType := undef;
gi_property_info_gt       : &GType := undef;
gi_field_info_gt          : &GType := undef;
gi_arg_info_gt            : &GType := undef;
gi_type_info_gt           : &GType := undef;
gi_unresolved_info_gt     : &GType := undef;

block
{
    gi_base_info_get_type           : () ~> GType;
    gi_callable_info_get_type       : () ~> GType;
    gi_function_info_get_type       : () ~> GType;
    gi_callback_info_get_type       : () ~> GType;
    gi_registered_type_info_get_type: () ~> GType;
    gi_struct_info_get_type         : () ~> GType;
    gi_union_info_get_type          : () ~> GType;
    gi_enum_info_get_type           : () ~> GType;
    gi_flags_info_get_type          : () ~> GType;
    gi_object_info_get_type         : () ~> GType;
    gi_interface_info_get_type      : () ~> GType;
    gi_constant_info_get_type       : () ~> GType;
    gi_value_info_get_type          : () ~> GType;
    gi_signal_info_get_type         : () ~> GType;
    gi_vfunc_info_get_type          : () ~> GType;
    gi_property_info_get_type       : () ~> GType;
    gi_field_info_get_type          : () ~> GType;
    gi_arg_info_get_type            : () ~> GType;
    gi_type_info_get_type           : () ~> GType;
    gi_unresolved_info_get_type     : () ~> GType;

    gi_base_info_gt            := gi_base_info_get_type();
    gi_callable_info_gt        := gi_callable_info_get_type();
    gi_function_info_gt        := gi_function_info_get_type();
    gi_callback_info_gt        := gi_callback_info_get_type();
    gi_registered_type_info_gt := gi_registered_type_info_get_type();
    gi_struct_info_gt          := gi_struct_info_get_type();
    gi_union_info_gt           := gi_union_info_get_type();
    gi_enum_info_gt            := gi_enum_info_get_type();
    gi_flags_info_gt           := gi_flags_info_get_type();
    gi_object_info_gt          := gi_object_info_get_type();
    gi_interface_info_gt       := gi_interface_info_get_type();
    gi_constant_info_gt        := gi_constant_info_get_type();
    gi_value_info_gt           := gi_value_info_get_type();
    gi_signal_info_gt          := gi_signal_info_get_type();
    gi_vfunc_info_gt           := gi_vfunc_info_get_type();
    gi_property_info_gt        := gi_property_info_get_type();
    gi_field_info_gt           := gi_field_info_get_type();
    gi_arg_info_gt             := gi_arg_info_get_type();
    gi_type_info_gt            := gi_type_info_get_type();
    gi_unresolved_info_gt      := gi_unresolved_info_get_type();
}


//---------------------------------------------------------------------
g_type_name_from_instance: (*void) ~> *const char;

g_type_check_instance_is_a: (*void, GType) ~> int;


#define GI_IS_BASE_INFO           : (bi)  =  g_type_check_instance_is_a(bi, gi_base_info_gt           );
#define GI_IS_CALLABLE_INFO       : (bi)  =  g_type_check_instance_is_a(bi, gi_callable_info_gt       );
#define GI_IS_FUNCTION_INFO       : (bi)  =  g_type_check_instance_is_a(bi, gi_function_info_gt       );
#define GI_IS_CALLBACK_INFO       : (bi)  =  g_type_check_instance_is_a(bi, gi_callback_info_gt       );
#define GI_IS_REGISTERED_TYPE_INFO: (bi)  =  g_type_check_instance_is_a(bi, gi_registered_type_info_gt);
#define GI_IS_STRUCT_INFO         : (bi)  =  g_type_check_instance_is_a(bi, gi_struct_info_gt         );
#define GI_IS_UNION_INFO          : (bi)  =  g_type_check_instance_is_a(bi, gi_union_info_gt          );
#define GI_IS_ENUM_INFO           : (bi)  =  g_type_check_instance_is_a(bi, gi_enum_info_gt           );
#define GI_IS_FLAGS_INFO          : (bi)  =  g_type_check_instance_is_a(bi, gi_flags_info_gt          );
#define GI_IS_OBJECT_INFO         : (bi)  =  g_type_check_instance_is_a(bi, gi_object_info_gt         );
#define GI_IS_INTERFACE_INFO      : (bi)  =  g_type_check_instance_is_a(bi, gi_interface_info_gt      );
#define GI_IS_CONSTANT_INFO       : (bi)  =  g_type_check_instance_is_a(bi, gi_constant_info_gt       );
#define GI_IS_VALUE_INFO          : (bi)  =  g_type_check_instance_is_a(bi, gi_value_info_gt          );
#define GI_IS_SIGNAL_INFO         : (bi)  =  g_type_check_instance_is_a(bi, gi_signal_info_gt         );
#define GI_IS_VFUNC_INFO          : (bi)  =  g_type_check_instance_is_a(bi, gi_vfunc_info_gt          );
#define GI_IS_PROPERTY_INFO       : (bi)  =  g_type_check_instance_is_a(bi, gi_property_info_gt       );
#define GI_IS_FIELD_INFO          : (bi)  =  g_type_check_instance_is_a(bi, gi_field_info_gt          );
#define GI_IS_ARG_INFO            : (bi)  =  g_type_check_instance_is_a(bi, gi_arg_info_gt            );
#define GI_IS_TYPE_INFO           : (bi)  =  g_type_check_instance_is_a(bi, gi_type_info_gt           );
#define GI_IS_UNRESOLVED_INFO     : (bi)  =  g_type_check_instance_is_a(bi, gi_unresolved_info_gt     );


//---------------------------------------------------------------------
GI_FUNCTION_IS_METHOD      = 1 << 0;
GI_FUNCTION_IS_CONSTRUCTOR = 1 << 1;
GI_FUNCTION_IS_GETTER      = 1 << 2;
GI_FUNCTION_IS_SETTER      = 1 << 3;
GI_FUNCTION_WRAPS_VFUNC    = 1 << 4;
GI_FUNCTION_IS_ASYNC       = 1 << 5;

//---------------------------------------------------------------------
gi_function_info_get_symbol: (*GIBaseInfo) ~> *const char;

gi_function_info_get_flags: (*GIBaseInfo) ~> unsigned;

gi_callable_info_get_n_args: (*GIBaseInfo) ~> unsigned;

gi_callable_info_get_arg: (*GIBaseInfo, unsigned) ~> *GIBaseInfo;

gi_callable_info_can_throw_gerror: (*GIBaseInfo) ~> int;

gi_arg_info_get_type_info: (*GIBaseInfo) ~> *GIBaseInfo;

gi_type_info_get_tag:    (*GIBaseInfo) ~> int;
gi_type_info_is_pointer: (*GIBaseInfo) ~> int;

gi_type_tag_to_string: (int) ~> *const char;

gi_callable_info_get_return_type: (*GIBaseInfo) ~> *GIBaseInfo;


//---------------------------------------------------------------------
GI_TYPE_TAG_VOID      =  0;
GI_TYPE_TAG_BOOLEAN   =  1;
GI_TYPE_TAG_INT8      =  2;     // Start of GI_TYPE_TAG_IS_NUMERIC types
GI_TYPE_TAG_UINT8     =  3;
GI_TYPE_TAG_INT16     =  4;
GI_TYPE_TAG_UINT16    =  5;
GI_TYPE_TAG_INT32     =  6;
GI_TYPE_TAG_UINT32    =  7;
GI_TYPE_TAG_INT64     =  8;
GI_TYPE_TAG_UINT64    =  9;
GI_TYPE_TAG_FLOAT     = 10;
GI_TYPE_TAG_DOUBLE    = 11;     // End of numeric types
GI_TYPE_TAG_GTYPE     = 12;
GI_TYPE_TAG_UTF8      = 13;
GI_TYPE_TAG_FILENAME  = 14;
// Non-basic types; compare with GI_TYPE_TAG_IS_BASIC
GI_TYPE_TAG_ARRAY     = 15;     // container (see GI_TYPE_TAG_IS_CONTAINER)
GI_TYPE_TAG_INTERFACE = 16;
GI_TYPE_TAG_GLIST     = 17;     // container
GI_TYPE_TAG_GSLIST    = 18;     // container
GI_TYPE_TAG_GHASH     = 19;     // container
GI_TYPE_TAG_ERROR     = 20;
// Another basic type
GI_TYPE_TAG_UNICHAR   = 21;

//---------------------------------------------------------------------
#define GI_TYPE_TAG_IS_BASIC: (tag)  =  tag < GI_TYPE_TAG_ARRAY  ||  tag == GI_TYPE_TAG_UNICHAR;

//---------------------------------------------------------------------
GI_ARRAY_TYPE_C          = 0;
GI_ARRAY_TYPE_ARRAY      = 1;
GI_ARRAY_TYPE_PTR_ARRAY  = 2;
GI_ARRAY_TYPE_BYTE_ARRAY = 3;

gi_type_info_get_array_type: (*GIBaseInfo) ~> int;

gi_type_info_get_param_type: (*GIBaseInfo, unsigned) ~> *GIBaseInfo;

gi_type_info_get_array_length_index: (*GIBaseInfo, *unsigned) ~> int;
gi_type_info_get_array_fixed_size: (*GIBaseInfo, *size_t) ~> int;
gi_type_info_is_zero_terminated: (*GIBaseInfo) ~> int;

gi_type_info_get_interface: (*GIBaseInfo) ~> *GIBaseInfo;


//---------------------------------------------------------------------
GI_DIRECTION_IN    = 0;
GI_DIRECTION_OUT   = 1;
GI_DIRECTION_INOUT = 2;

gi_arg_info_get_direction: (*GIBaseInfo) ~> int;


//---------------------------------------------------------------------
gi_object_info_get_n_methods: (*GIBaseInfo) ~> unsigned;

gi_object_info_get_method: (*GIBaseInfo, unsigned) ~> *GIBaseInfo;


//---------------------------------------------------------------------
gi_enum_info_get_storage_type: (*GIBaseInfo) ~> int;


//---------------------------------------------------------------------
the_gir: &*GIRepository := undef;


//---------------------------------------------------------------------
print_base_info: (bi: *GIBaseInfo) ~> void
{
    if (GI_IS_REGISTERED_TYPE_INFO(bi))
    {
        g_type_name: (GType) ~> *const char;

        g_type_parent: (GType) ~> GType;

        gi_repository_find_by_gtype: (*GIRepository, GType) ~> *GIBaseInfo;

        gi_registered_type_info_get_g_type: (*GIBaseInfo) ~> GType;

        gt: &GType := gi_registered_type_info_get_g_type(bi);

        gt := g_type_parent(gt);

        for (; gt; gt := g_type_parent(gt))
        {
            info = gi_repository_find_by_gtype(the_gir, gt);

            if (!info)
            {
                printf("?%s ", g_type_name(gt));

                break;
            }

            defer gi_base_info_unref(info);

            ns = gi_base_info_get_namespace(info);

            name = gi_base_info_get_name(info);

            printf("%s.%s ", ns, name);
        }
    }

    tn = g_type_name_from_instance(bi);

    printf(":%s", tn);
}


//---------------------------------------------------------------------
print_type_info: (bi: *GIBaseInfo) ~> void
{
    is_pointer = gi_type_info_is_pointer(bi);

    if (is_pointer) printf("ptr ");

    tag = gi_type_info_get_tag(bi);

    if (GI_TYPE_TAG_IS_BASIC(tag))
    {
        printf("%s", gi_type_tag_to_string(tag));

        return;
    }

    switch(tag)
    {
    case GI_TYPE_TAG_ARRAY:
      {
        name: &*const char := undef;

        switch(gi_type_info_get_array_type(bi))
        {
        case GI_ARRAY_TYPE_C:          name := "array";          break;
        case GI_ARRAY_TYPE_ARRAY:      name := "GLib.Array";     break;
        case GI_ARRAY_TYPE_PTR_ARRAY:  name := "GLib.PtrArray";  break;
        case GI_ARRAY_TYPE_BYTE_ARRAY: name := "GLib.ByteArray"; break;
        }

        printf("%s(", name);

        type = gi_type_info_get_param_type(bi, 0);      defer gi_base_info_unref(type);
        print_type_info(type);

        printf(" ");

        length: &unsigned := undef;
        size:   &size_t   := undef;

        if (gi_type_info_get_array_length_index(bi, &length))   printf("l=%u ", length);
        if (gi_type_info_get_array_fixed_size(bi, &size))       printf("s=%zu ", size);
        if (gi_type_info_is_zero_terminated(bi))                printf("z");

        printf(")");

        break;
      }

    case GI_TYPE_TAG_INTERFACE:
      {
        iface = gi_type_info_get_interface(bi);         defer gi_base_info_unref(iface);

        ns = gi_base_info_get_namespace(iface);

        name = gi_base_info_get_name(iface);

        printf("%s.%s", ns, name);

        printf(" [");

        print_base_info(iface);

        printf("]");

        break;
      }

    case GI_TYPE_TAG_GLIST:
      {
        printf("GLib.List(");

        type = gi_type_info_get_param_type(bi, 0);      defer gi_base_info_unref(type);
        print_type_info(type);

        printf(")");

        break;
      }

    case GI_TYPE_TAG_GSLIST:
      {
        printf("GLib.SList(");

        type = gi_type_info_get_param_type(bi, 0);      defer gi_base_info_unref(type);
        print_type_info(type);

        printf(")");

        break;
      }

    case GI_TYPE_TAG_GHASH:
      {
        printf("GLib.HashTable(");

        typ0 = gi_type_info_get_param_type(bi, 0);      defer gi_base_info_unref(typ0);
        print_type_info(typ0);

        printf(", ");

        typ1 = gi_type_info_get_param_type(bi, 1);      defer gi_base_info_unref(typ1);
        print_type_info(typ0);

        printf(")");

        break;
      }

    case GI_TYPE_TAG_ERROR:
      {
        printf("GLib.Error");

        break;
      }

    default:
        v_assert(false);
    }
}


//---------------------------------------------------------------------
compute_voidc_basic_type: (tag: int) ~> *v_type_t
{
    switch(tag)
    {
    case GI_TYPE_TAG_VOID:      return v_void_type();
    case GI_TYPE_TAG_BOOLEAN:   return v_find_type("int");
    case GI_TYPE_TAG_INT8:      return v_int_type(8);
    case GI_TYPE_TAG_UINT8:     return v_uint_type(8);
    case GI_TYPE_TAG_INT16:     return v_int_type(16);
    case GI_TYPE_TAG_UINT16:    return v_uint_type(16);
    case GI_TYPE_TAG_INT32:     return v_int_type(32);
    case GI_TYPE_TAG_UINT32:    return v_uint_type(32);
    case GI_TYPE_TAG_INT64:     return v_int_type(64);
    case GI_TYPE_TAG_UINT64:    return v_uint_type(64);
    case GI_TYPE_TAG_FLOAT:     return v_f32_type();
    case GI_TYPE_TAG_DOUBLE:    return v_f64_type();
    case GI_TYPE_TAG_GTYPE:     return v_find_type("size_t");
    case GI_TYPE_TAG_UNICHAR:   return v_uint_type(32);

    case GI_TYPE_TAG_UTF8:
    case GI_TYPE_TAG_FILENAME:

        return  v_int_type(8);                          //- ???
//      return  v_pointer_type(v_int_type(8), 0);       //- ???
    }

    v_assert(false);
}

//---------------------------------------------------------------------
compute_voidc_type: (ti: *GIBaseInfo) ~> *v_type_t
{
    tag = gi_type_info_get_tag(ti);

    if (GI_TYPE_TAG_IS_BASIC(tag))  return compute_voidc_basic_type(tag);

    switch(tag)
    {
    case GI_TYPE_TAG_ARRAY:

        if (gi_type_info_get_array_type(ti) == GI_ARRAY_TYPE_C)
        {
            type = gi_type_info_get_param_type(ti, 0);      defer gi_base_info_unref(type);

            t = compute_voidc_type(type);

            if (t) return v_pointer_type(t, 0);
        }

        break;

    case GI_TYPE_TAG_INTERFACE:
      {
        iface = gi_type_info_get_interface(ti);         defer gi_base_info_unref(iface);

        v_assert(GI_IS_REGISTERED_TYPE_INFO(iface)  ||  GI_IS_CALLBACK_INFO(iface));

        if (GI_IS_ENUM_INFO(iface))
        {
            etag = gi_enum_info_get_storage_type(iface);

            return  compute_voidc_basic_type(etag);
        }
        else if (GI_IS_CALLBACK_INFO(iface))
        {
            return  v_pointer_type(v_void_type(), 0);       //- !!!
        }
        else
        {
            return  v_void_type();                          //- !!!
        }
      }
    }

    return 0;
}

//---------------------------------------------------------------------
print_voidc_type: (ti: *GIBaseInfo, dir: int) ~> bool
{
    t = compute_voidc_type(ti);         if (!t) return false;

    t: &*v_type_t := t;

    if (gi_type_info_is_pointer(ti))  t := v_pointer_type(t, 0);

    if (dir > GI_DIRECTION_IN)  t := v_pointer_type(t, 0);

    sstr: &v_std_string_t := {};

    voidc_internal_std_string_append_type(&sstr, t);

    printf("%s", v_std_string_get(&sstr));

    return true;
}


//---------------------------------------------------------------------
print_callable_info: (bi: *GIBaseInfo) ~> void
{
    n = gi_callable_info_get_n_args(bi);

    for (i: &int := 0; i < n; ++i)
    {
        printf("%15s %d ", "arg:", i);

        a = gi_callable_info_get_arg(bi, i);        defer gi_base_info_unref(a);

        d = gi_arg_info_get_direction(a);

        switch(d)
        {
        case GI_DIRECTION_IN:     printf("in ");    break;
        case GI_DIRECTION_OUT:    printf("out ");   break;
        case GI_DIRECTION_INOUT:  printf("inout "); break;
        }

        t = gi_arg_info_get_type_info(a);           defer gi_base_info_unref(t);

        print_type_info(t);

        printf("  {");

        if (!print_voidc_type(t, d))  printf("?");

        printf("}");

        printf("\n");
    }

    if (gi_callable_info_can_throw_gerror(bi))
    {
        printf("%15s %s\n", "error:", "can throw GError");
    }

    printf("%15s ", "ret:");

    r = gi_callable_info_get_return_type(bi);       defer gi_base_info_unref(r);

    print_type_info(r);

    printf("  {");

    if (!print_voidc_type(r, -1)) printf("?");

    printf("}");

    printf("\n");
}



//---------------------------------------------------------------------
print_function_info: (bi: *GIBaseInfo) ~> void
{
    s = gi_function_info_get_symbol(bi);

    printf("%15s %s\n", "symbol:", s);

    print_callable_info(bi);
}

//---------------------------------------------------------------------
print_callback_info : (bi: *GIBaseInfo) ~> void
{
}

//---------------------------------------------------------------------
print_struct_info   : (bi: *GIBaseInfo) ~> void
{
}

//---------------------------------------------------------------------
print_union_info    : (bi: *GIBaseInfo) ~> void
{
}

//---------------------------------------------------------------------
print_enum_info     : (bi: *GIBaseInfo) ~> void
{
}

//---------------------------------------------------------------------
print_constant_info : (bi: *GIBaseInfo) ~> void
{
}


//---------------------------------------------------------------------
print_object_info   : (bi: *GIBaseInfo) ~> void
{

    for (n = gi_object_info_get_n_methods(bi), i: &unsigned := 0; i < n; ++i)
    {
        f = gi_object_info_get_method(bi, i);       defer gi_base_info_unref(f);

        flags = gi_function_info_get_flags(f);

        kind: &*const char := undef;

        if (flags & GI_FUNCTION_IS_CONSTRUCTOR)   kind := "constructor";
        else if (flags & GI_FUNCTION_IS_METHOD)   kind := "method";
        else                                      kind := "function";

        m = gi_base_info_get_name(f);

        printf("%14s: %s\n", kind, m);

        print_function_info(f);
    }

}


//---------------------------------------------------------------------
print_interface_info: (bi: *GIBaseInfo) ~> void
{
}




//----------------- ----------------------------------------------------
{
    gir = gi_repository_new();          defer g_object_unref(gir);

    the_gir := gir;

//  printf("gir: %p\n", gir);

    gt_name    = "GIRepository";
    gt_version = "3.0";

//    gt_name    = "GObject";
//    gt_version = 0; // "2.0";

//    gt_name    = "GLib";
//    gt_version = 0; // "2.0";

//    gt_name    = "Gtk";
//    gt_version = "3.0";

    printf("name: %s, version: %s\n", gt_name, gt_version);

    gt = gi_repository_require(gir, gt_name, gt_version, 0, 0);
    defer gi_typelib_unref(gt);

//  printf("gt: %p\n", gt);

    N = gi_repository_get_n_infos(gir, gt_name);

    printf("N: %d\n", N);

    for (i: &int := 0; i < N; ++i)
    {
        bi = gi_repository_get_info(gir, gt_name, i);
        defer gi_base_info_unref(bi);

        n = gi_base_info_get_name(bi);

        tn = g_type_name_from_instance(bi);

        printf("%15s %s\n", tn, n);

        if (GI_IS_FUNCTION_INFO(bi))
        {
            print_function_info(bi);
        }
        else if(GI_IS_CALLBACK_INFO(bi))
        {
//          print_callback_info(bi);
        }
        else if(GI_IS_STRUCT_INFO(bi))
        {
//          print_struct_info(bi);
        }
        else if(GI_IS_UNION_INFO(bi))
        {
//          print_union_info(bi);
        }
        else if(GI_IS_ENUM_INFO(bi))        //- ...
        {
//          print_enum_info(bi);
        }
        else if(GI_IS_CONSTANT_INFO(bi))
        {
//          print_constant_info(bi);
        }
        else if(GI_IS_OBJECT_INFO(bi))
        {
            print_object_info(bi);
        }
        else if(GI_IS_INTERFACE_INFO(bi))
        {
//          print_interface_info(bi);
        }
    }




}


