{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");

    v_import("try_blocks_etc.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();

    voidc_enable_blocks_etc();
}

{   v_assert(v_find_symbol_type("v_push_result")); }


//=====================================================================
{   voidc_unit_begin_module("local_objects_module"); }

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("enabled_q", q_ref, q("voidc.internal.local_objects_enabled"));

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));

    v_add_symbol("voidc_internal_return_value_q",        q_ref, q("voidc.internal_return_value"));
    v_add_symbol("voidc_internal_branch_target_leave_q", q_ref, q("voidc.internal_branch_target_leave"));
    v_add_symbol("voidc_internal_break_value_q",         q_ref, q("voidc.internal_break_value"));

    v_add_symbol("q_cast",  q_ref, q("v_cast"));
    v_add_symbol("q_break", q_ref, q("v_break"));

    v_add_symbol("voidc_incomplete_array_type_tag", q_ref, q("voidc.incomplete_array_type_tag"));

    v_add_symbol("q_op_braces", q_ref, q("v.op_braces"));

    v_add_symbol("int_q",  q_ref, q("int"));

    v_add_symbol("q_op_postfix_index", q_ref, q("v.op_postfix_index"));

    v_add_symbol("q_static_type_t", q_ref, q("v_static_type_t"));
}


//---------------------------------------------------------------------
//- local_objects_ctx_t ...
//---------------------------------------------------------------------
private
my_prepare_function_parameters_helper_t = struct
{
    fun: *((*void, LLVMValueRef, *v_type_t, *v_ast_generic_list_t) ~> void);
    aux: *void;
};

private
my_tmp_action_ctx_t = struct
{
    fun: *((*void) ~> void);
    aux: *void;
};

private
struct v_tmp_cleaner_item_t
{
    act:  my_tmp_action_ctx_t;
    next: *v_tmp_cleaner_item_t;
};

private
struct v_tmp_cleaner_stack_t
{
    stack: *v_tmp_cleaner_item_t;
    next:  *v_tmp_cleaner_stack_t;
};

private
my_make_temporary_ctx_t = struct
{
    fun: *((*void, *v_type_t, LLVMValueRef) ~> LLVMValueRef);
    aux: *void;
};

private
my_intrinsic_ctx_t = struct
{
    fun: *((*void, *voidc_visitor_t, *v_ast_base_t) ~> void);
    aux: *void;
};

private
my_try_to_adopt_ctx_t = struct
{
    fun: *((*void, *v_type_t, LLVMValueRef) ~> bool);
    aux: *void;
};

private
my_try_to_convert_ctx_t = struct
{
    fun: *((*void, *v_type_t, LLVMValueRef, *v_type_t, &LLVMValueRef) ~> bool);
    aux: *void;
};

private
op_postfix_index_helper_ctx_t = struct
{
    fun: *((aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
            agg_t: &*v_type_t, agg_v: &LLVMValueRef,
            idx: **v_ast_expr_list_t, count: unsigned
           ) ~> bool);

    aux: *void;
};

private
my_compute_key_quark_type_t = struct
{
    fun: *((*void, *v_type_t, &v_quark_t) ~> *v_type_t);
    aux: *void;
};


//---------------------------------------------------------------------
private alwaysinline
(_()): (ctx: &my_tmp_action_ctx_t) ~> void
{
    ctx.fun(ctx.aux);
}

private alwaysinline
(_()): (ctx: &my_make_temporary_ctx_t, t: *v_type_t, v: LLVMValueRef) ~> LLVMValueRef
{
    v_return(ctx.fun(ctx.aux, t, v));
}

private alwaysinline
(_()): (ctx: &my_intrinsic_ctx_t, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx.fun(ctx.aux, vis, self);
}

private alwaysinline
(_()): (ctx: &my_try_to_adopt_ctx_t, t: *v_type_t, v: LLVMValueRef) ~> bool
{
    v_return(ctx.fun(ctx.aux, t, v));
}

private alwaysinline
(_()): (ctx: &my_try_to_convert_ctx_t, t0: *v_type_t, v0: LLVMValueRef, t1: *v_type_t, v1: &LLVMValueRef) ~> bool
{
    v_return(ctx.fun(ctx.aux, t0, v0, t1, v1));
}


//---------------------------------------------------------------------
private
local_objects_ctx_t = struct
{
    fun_params: my_prepare_function_parameters_helper_t;        //- ...

    cleaners_stack: *v_tmp_cleaner_stack_t;

    push_temporaries: my_tmp_action_ctx_t;
    pop_temporaries:  my_tmp_action_ctx_t;
    make_temporary:   my_make_temporary_ctx_t;

    compile_stmt: my_intrinsic_ctx_t;

    try_to_adopt:   my_try_to_adopt_ctx_t;
    try_to_convert: my_try_to_convert_ctx_t;
    return:         my_intrinsic_ctx_t;
    break:          my_intrinsic_ctx_t;
    op_braces:      my_intrinsic_ctx_t;
    key_quark:      my_compute_key_quark_type_t;
    op_index:       op_postfix_index_helper_ctx_t;
};


//=====================================================================
private
my_fake_utility_intrinsic: (aux: *void, *voidc_visitor_t, *v_ast_base_t,
                            **v_ast_expr_t, unsigned) ~> void
{
    q = v_quark_to_string((aux: v_quark_t));

    printf: (*const char, ...) ~> int;

    printf("my_fake_utility_intrinsic: %s\n", q);

    abort: () ~> void;

    abort();        //- Sic!
}

//---------------------------------------------------------------------
my_fake_utility_intrinsic_ctor: () ~> void
{
    sstr = v_make_object(v_std_string_t);

    qnames: &(*const char)[] :=
    {
        "v_initialize",
        "v_terminate",
        "v_copy",
        0
    };

    for (name: &**const char := &qnames[0]; *name; ++name)
    {
        v_std_string_set(sstr, "v.internal.fake_utility.");

        v_std_string_append(sstr, *name);

        q_fake = v_quark_from_string(v_std_string_get(sstr));
        q_name = v_quark_from_string(*name);

        v_add_intrinsic_q(q_fake, my_fake_utility_intrinsic, (q_name: *void));
    }
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) ~> bool;

//---------------------------------------------------------------------
v_type_check_special: (t: *v_type_t, q: v_quark_t) ~> void
{
    switch(v_kind(t))
    {
    case v_type_kind_array:
    case v_type_kind_struct:
    case v_type_kind_generic:
        v_break();

    default:
        v_return();
    }

    sstr = v_make_object(v_std_string_t);

    v_std_string_set(sstr, v_quark_to_string(q));

    v_std_string_append(sstr, ".checked");

    q_checked = v_quark_from_string(v_std_string_get(sstr));

    if (v_get_overload_q(q_checked, t))  v_return();

    block
    {
        if (v_get_overload_q(q, t))  v_break();

        if (v_type_is_array(t))
        {
            v_type_check_special(v_type_array_get_element_type(t), q);
            v_break();
        }

        flag: &bool := false;

        if (v_type_is_struct(t))
        {
            count = v_type_struct_get_element_count(t);
            types = v_type_struct_get_element_types(t);

            for (i: &int := 0; i < count; ++i)
            {
                flag |= v_type_is_special(types[i], q);

                if (flag)   v_break();
            }
        }
        else
        {
            v_assert(v_type_is_generic(t));

            if (v_type_generic_get_cons(t) != voidc_incomplete_array_type_tag)  v_break();

            arg0 = v_type_generic_get_args(t)[0];

            type = v_type_generic_arg_type_get_type(arg0);

            flag := v_type_is_special(type, q);
        }

        if (flag)
        {
            v_std_string_set(sstr, "v.internal.fake_utility.");

            v_std_string_append(sstr, v_quark_to_string(q));

            q_fake = v_quark_from_string(v_std_string_get(sstr));

            v_add_overload_q(q, t, q_fake);
        }
    }

    v_add_overload_q(q_checked, t, q_checked);          //- ?!?!?
}


//---------------------------------------------------------------------
export
v_type_is_special: (t: *v_type_t, q: v_quark_t) ~> bool
{
    if (t == INVIOLABLE_TAG)  v_return(false);          //- ?
    if (t == UNREFERENCE_TAG) v_return(false);          //- ?

    switch(v_kind(t))
    {
    case v_type_kind_array:
        v_return(v_type_is_special(v_type_array_get_element_type(t), q));

    case v_type_kind_struct:
    case v_type_kind_generic:
        v_break();

    default:
        v_return(false);        //- Sic!!!
    }

    v_type_check_special(t, q);

    v_return(v_get_overload_q(q, t) != 0);
}


//=====================================================================
private
my_type_function_obtain_llvm_type: (*void, ft: *v_type_t) ~> LLVMTypeRef
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    n: &unsigned := par_count;

    rt = v_type_function_get_return_type(ft);

    rt_initializable = v_type_is_special(rt, q_initialize);

    if (rt_initializable) ++n;

    par = v_malloc(LLVMTypeRef, n);
    defer v_free(par);

    llvm_ctx = v_target_get_llvm_ctx();

    llvm_ptr = LLVMPointerTypeInContext(llvm_ctx, 0);

    ppar: &*LLVMTypeRef := par;

    if (rt_initializable)
    {
        par[0] := llvm_ptr;

        ++ppar;
    }

    for(i: &unsigned := 0; i < par_count; ++i, ++ppar)
    {
        pt = par_types[i];

        if (v_type_is_special(pt, q_initialize))  *ppar := llvm_ptr;
        else                                      *ppar := v_type_get_llvm_type(pt);
    }

    ret: &LLVMTypeRef := v_undef();

    if (rt_initializable)   ret := LLVMVoidTypeInContext(llvm_ctx);
    else                    ret := v_type_get_llvm_type(rt);

    var_arg = v_type_function_is_var_arg(ft);

    ret = LLVMFunctionType(ret, par, n, var_arg);

    v_type_set_cached_llvm_type(ft, ret);

    v_return(ret);
}


//=====================================================================
private
my_prepare_function_parameters: (aux: *void, fun: LLVMValueRef,
                                 fun_type: *v_type_t,
                                 fun_args: *v_ast_generic_list_t
                                ) ~> void
{
    tr = v_type_function_get_return_type(fun_type);

    if (!v_type_is_special(tr, q_initialize))
    {
        ctx = (aux: *local_objects_ctx_t)->fun_params;

        ctx.fun(ctx.aux, fun, fun_type, fun_args);

        v_return();
    }

    vr = LLVMGetParam(fun, 0);

    v_add_variable_q(voidc_internal_return_value_q, tr, vr);         //- Sic!

    count = v_type_function_get_param_count(fun_type);
    types = v_type_function_get_param_types(fun_type);

    for (i: &int := 0; i < count; ++i)
    {
        item = (v_list_get_item(fun_args, i) : *v_ast_generic_list_t);

        etmp = (v_list_get_item(item, 0) : *v_ast_expr_t);

        if (!v_empty(etmp))
        {
            pname = v_ast_expr_identifier_get_name(etmp);

            v_add_parameter_name(fun, i+1, pname, types[i]);
        }
    }
}


//=====================================================================
//- ...
//=====================================================================
export
voidc_make_special_intrinsic_call: (stmt: *v_ast_stmt_t, q: v_quark_t,
                                    t: *v_type_t, v0: LLVMValueRef, v1: LLVMValueRef
                                    ) ~> void
{
    v_assert(q == q_initialize  ||  q == q_terminate  ||  q == q_copy);         //- Sic!

    expr = v_make_object(v_ast_expr_t, 4);

    t_ptr = v_pointer_type(t, 0);           //- 0?

    v_ast_make_expr_compiled(expr+0, t_ptr, v0);

    is_copy = q == q_copy;

    if (is_copy) v_ast_make_expr_compiled(expr+1, t_ptr, v1);

    length: &uint64_t := 1;

    if (v_type_is_array(t))
    {
        et: &*v_type_t := t;

        loop
        {
            length *= v_type_array_get_length(et);

            et := v_type_array_get_element_type(et);

            if (!v_type_is_array(et))   v_break();
        }

        v_assert(length != 0);              //- WTF ?..

        expr_list = v_make_object(v_ast_expr_list_t);

        v_make_list(expr_list, expr+0, 1);

        ep = v_pointer_type(et, 0);         //- 0?

        v_ast_make_expr_compiled(expr+2, v_find_type_q(q_static_type_t), (ep: LLVMValueRef));

        v_list_append(expr_list, expr_list, expr+2, 1);

        v_ast_make_expr_identifier_q(expr+3, q_cast);

        v_ast_make_expr_call(expr+0, expr+3, expr_list);

        if (is_copy)
        {
            v_make_list(expr_list, expr+1, 2);          //- !..

            v_ast_make_expr_call(expr+1, expr+3, expr_list);
        }
    }

    if (is_copy)
    {
        v_ast_make_expr_integer(expr+2, (length: intptr_t));

        v_ast_make_stmt_call(stmt, 0, q, expr+0, 3);
    }
    else
    {
        v_ast_make_expr_integer(expr+1, (length: intptr_t));

        v_ast_make_stmt_call(stmt, 0, q, expr+0, 2);
    }
}


//=====================================================================
//- Temporary cleaners ...
//---------------------------------------------------------------------
private
my_push_temporaries: (aux: *void) ~> void
{
    ctx = *(aux: *local_objects_ctx_t);

    ctx.push_temporaries();

    stack = *v_malloc(v_tmp_cleaner_stack_t) := { 0, ctx.cleaners_stack };

    ctx.cleaners_stack := &stack;
}

//---------------------------------------------------------------------
private
my_pop_temporaries: (aux: *void) ~> void
{
    ctx = *(aux: *local_objects_ctx_t);

    stack = ctx.cleaners_stack;

    for (it: &*v_tmp_cleaner_item_t := stack->stack; it; )
    {
        it->act();

        next = v_load(&it->next);

        v_free(it);

        it := next;
    }

    next = v_load(&stack->next);

    v_free(stack);

    stack := next;

    ctx.pop_temporaries();
}

//---------------------------------------------------------------------
private
add_temporary_cleaner_helper: (void_ctx: *void, fun: *((*void) ~> void), aux: *void) ~> void
{
    ctx = *(void_ctx: *local_objects_ctx_t);

    stack = ctx.cleaners_stack->stack;

    item = *v_malloc(v_tmp_cleaner_item_t) := { {fun, aux}, stack };

    stack := &item;
}

//---------------------------------------------------------------------
#do (v_make_handler(v_add_temporary_cleaner, add_temporary_cleaner_helper))


//---------------------------------------------------------------------
private
my_temporary_cleaner_ctx_t = struct
{
    typ: *v_type_t;
    val: LLVMValueRef;
};

private
my_temporary_cleaner: (void_ctx: *void) ~> void
{
    ctx = *(void_ctx: *my_temporary_cleaner_ctx_t);
    defer v_free(&ctx);

    v_assert(v_type_is_special(ctx.typ, q_terminate));

    stmt = v_make_object(v_ast_stmt_t);

    voidc_make_special_intrinsic_call(stmt, q_terminate, ctx.typ, ctx.val, 0);

    v_push_result();

    v_ast_accept_visitor((stmt: *v_ast_base_t), v_get_compiler());

    v_pop_result();
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_make_temporary: (aux: *void, t: *v_type_t, v: LLVMValueRef) ~> LLVMValueRef
{
//printf("my_make_temporary: start\n");
//defer printf("my_make_temporary: stop\n");

    ctx = *(aux: *local_objects_ctx_t);

    if (!v_type_is_special(t, q_initialize))
    {
        v_return(ctx.make_temporary(t, v));
    }

    v_push_result();

    vis = v_get_compiler();

    rv = ctx.make_temporary(t, 0);

    stmt = v_make_object(v_ast_stmt_t);

    voidc_make_special_intrinsic_call(stmt, q_initialize, t, rv, 0);

    v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

    if (v  &&  v_type_is_special(t, q_copy))
    {
        voidc_make_special_intrinsic_call(stmt, q_copy, t, rv, v);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }

    if (v_type_is_special(t, q_terminate))
    {
        ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {t, rv};

        v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
    }

    v_pop_result();

    v_return(rv);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_compile_stmt: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    expr = v_ast_stmt_get_expr((self: *v_ast_stmt_t));
    if (v_empty(expr))  v_return();                             //- Sic!

    name = v_ast_stmt_get_name((self: *v_ast_stmt_t));

    anchor: &LLVMValueRef := 0;

    builder = v_target_get_builder();

    if (name  &&  name[0])
    {
        llvm_ctx = v_target_get_llvm_ctx();

        ptr_ = LLVMPointerTypeInContext(llvm_ctx, 0);           //- 0?

        anchor := LLVMBuildLoad2(builder, ptr_, LLVMGetUndef(ptr_), "anchor");
    }

    v_reset_result();

    if (anchor) v_set_result_value(anchor);

    //---------------------------------------------------
    (aux: *local_objects_ctx_t)->compile_stmt(vis, self);
    //---------------------------------------------------

    if (!anchor)  v_return();

    t = v_get_variable_type(name);

    v: &LLVMValueRef := v_undef();

    if (v_type_is_special(t, q_initialize))
    {
        v_save_builder_ip();

        LLVMPositionBuilderBefore(builder, anchor);

        v := LLVMBuildAlloca(builder, v_type_get_llvm_type(t), name);

        stmt = v_make_object(v_ast_stmt_t);

        voidc_make_special_intrinsic_call(stmt, q_initialize, t, v, 0);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

        v_restore_builder_ip();

        if (v_type_is_special(t, q_terminate))
        {
            voidc_make_special_intrinsic_call(stmt, q_terminate, t, v, 0);

            v_ast_make_stmt_defer(stmt, stmt);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
        }

        LLVMReplaceAllUsesWith(anchor, v);

        v_add_variable(name, t, v);
    }

    LLVMInstructionEraseFromParent(anchor);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_llvm_build_call: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                     ft: *v_type_t, fv: LLVMValueRef,
                     arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                    ) ~> void
{
//printf("my_llvm_build_call: start %p\n", ft);
//defer printf("my_llvm_build_call: stop\n");

    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    par_count: &unsigned := par_count;
    arg_count: &unsigned := arg_count;

    tr = v_type_function_get_return_type(ft);

    tr_initializable = v_type_is_special(tr, q_initialize);

    if (tr_initializable)
    {
        ++par_count;
        ++arg_count;
    }

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    vr: &LLVMValueRef := v_undef();

    i: &unsigned := 0;

    if (tr_initializable)
    {
        vr := v_get_result_value();

        if (vr == 0)  vr := v_make_temporary(tr, 0);

        values[0] := vr;

        i := 1;
    }

    v_push_result();

    for (; i < arg_count; ++i)
    {
        j: &unsigned := v_undef();

        if (tr_initializable)   j := i-1;
        else                    j := i;

        v_reset_result();

        if (i < par_count)  v_set_result_type(par_types[j]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_ast_accept_visitor((arg_ptrs[j]: *v_ast_base_t), vis);

        values[i] := v_get_result_value();
    }

    builder = v_target_get_builder();

    ft_ = v_type_get_llvm_type(ft);

    _vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    if (!tr_initializable)  vr := _vr;

    v_pop_result();

    v_adopt_result(tr, vr);
}


//---------------------------------------------------------------------
//- try_to_adopt ...
//---------------------------------------------------------------------
private
my_try_to_adopt: (aux: *void, type: *v_type_t, value: LLVMValueRef) ~> bool
{
//printf("my_try_to_adopt: start\n");
//defer printf("my_try_to_adopt: stop\n");

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    flag: &bool := false;       //- "Perform default treatment"

    value: &LLVMValueRef := value;

    switch((ttag: intptr_t))
    {
    case -1:        //- Unreference...

        if (type == v_find_type_q(q_static_type_t))
        {
            flag := true;

            v_break();
        }

        if (v_type_is_reference(type))
        {
            et = v_type_refptr_get_element_type(type);

            if (!v_type_is_array(et)  &&  v_type_is_special(et, q_initialize))
            {
                v_set_result_type(et);
            }
            else
            {
                flag := true;
            }

            v_break();
        }

        if (v_type_is_array(type))
        {
            flag := true;

            v_break();
        }

        //- Fallthrough!

    case 0:         //- Get "as is"...

        if (v_type_is_special(type, q_initialize))          //- Sic !!!
        block
        {
            if (vtag == 0)      v_break();          //- !!!
            if (vtag == value)  v_break();

            vis = v_get_compiler();

            stmt = v_make_object(v_ast_stmt_t);

            voidc_make_special_intrinsic_call(stmt, q_copy, type, vtag, value);

            v_push_result();

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            v_pop_result();

            value := vtag;
        }

        v_set_result_type(type);

        v_break();

    default:        //- Adopt...
      {
        to_type: &*v_type_t := ttag;

        if (to_type != type)
        block
        {
            if (!v_type_is_generic(to_type))  v_break();

            if (v_type_generic_get_cons(to_type) != voidc_incomplete_array_type_tag)  v_break();

            to_type := type;
        }

        if (to_type != type)
        {
            vv: &LLVMValueRef := 0;

            v_convert_to_type(type, value, to_type, vv);

            value := vv;
        }

        //- Kinda,  value : to_type ...

        if (v_type_is_special(to_type, q_initialize))          //- Sic!
        block
        {
            if (vtag == 0)      v_break();          //- !!!
            if (vtag == value)  v_break();

            vis = v_get_compiler();

            stmt = v_make_object(v_ast_stmt_t);

            voidc_make_special_intrinsic_call(stmt, q_copy, to_type, vtag, value);

            v_push_result();

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

            v_pop_result();

            value := vtag;
        }

        v_set_result_type(to_type);         //- ?
      }
    }

    if (flag)       //- "Perform default treatment"
    {
        v_return((aux: *local_objects_ctx_t)->try_to_adopt(type, value));
    }

    v_set_result_value(value);

    v_return(true);
}

//---------------------------------------------------------------------
//- try_to_convert ...
//---------------------------------------------------------------------
private
my_try_to_convert: (aux: *void, t0: *v_type_t, v0: LLVMValueRef, t1: *v_type_t, v1: &LLVMValueRef) ~> bool
{
//printf("my_try_to_convert: start\n");
//defer printf("my_try_to_convert: stop %d\n", (v_get_return_value() : int));

    if (t0 == t1)
    {
        v1 := v0;

        v_return(true);
    }

    if (v_type_is_reference(t0))
    {
        if (et0 = v_type_refptr_get_element_type(t0), et0 == t1)
        {
            if (v_type_is_special(et0, q_initialize))
            {
                //- &T -> T,    T - object

                //- Kinda, NOP

                v1 := v0;

                v_return(true);
            }
        }
    }

    if (v_type_is_reference(t1))
    {
        if (et1 = v_type_refptr_get_element_type(t1), t0 == et1)
        {
            if (v_type_is_special(et1, q_initialize))
            {
                //- T -> &T,    T - object

                //- Kinda, NOP ???

                v1 := v0;

                v_return(true);
            }
        }
    }

    //- Default treatment...

    v_return((aux: *local_objects_ctx_t)->try_to_convert(t0, v0, t1, v1));
}


//=====================================================================
private
my_return_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    leave_bv = v_get_variable_value_q(voidc_internal_branch_target_leave_q);
    v_assert(leave_bv);

    call = (self: *v_ast_expr_t);

    arg_list = v_ast_expr_call_get_arg_list(call);

    args_count = v_list_get_size(arg_list);

    if (args_count)
    {
        ret_type = v_get_variable_type_q(voidc_internal_return_value_q);

        if (!v_type_is_special(ret_type, q_initialize))
        {
            (aux: *local_objects_ctx_t)->return(vis, self);

            v_return();
        }

        ret_value = v_get_variable_value_q(voidc_internal_return_value_q);

        v_reset_result();               //- !

        v_set_result_type(ret_type);
        v_set_result_value(ret_value);

        arg0 = v_list_get_item(arg_list, 0);

        v_ast_accept_visitor((arg0: *v_ast_base_t), vis);

        //- !
    }

    builder = v_target_get_builder();

    leave_b = LLVMValueAsBasicBlock(leave_bv);

    LLVMBuildBr(builder, leave_b);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_compile_expr_stmt: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_compile_expr_stmt start\n");
//defer printf("my_compile_expr_stmt stop\n");

    tr = v_get_result_type();

    vr: &LLVMValueRef := v_get_result_value();

    vr_temporary: &bool := vr == 0;

    block
    {
        if (vr_temporary)   v_break();

        //- Have some "anchor"

        if (tr == INVIOLABLE_TAG)   v_break();
        if (tr == UNREFERENCE_TAG)  v_break();

        //- tr - is a "real" type...

        if (v_type_is_special(tr, q_initialize))  v_break();

        vr_temporary := true;
    }

    if (vr_temporary)
    {
        vr := v_make_temporary(0, 0);
    }

    data: &struct { *v_type_t; LLVMValueRef; } := { 0, vr };


    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *v_ast_expr_stmt_t);


    v_save_variables();

    v_add_variable_q(voidc_internal_break_value_q, tr, (&data : LLVMValueRef));


    v_push_result();

    builder = v_target_get_builder();

    llvm_ctx = v_target_get_llvm_ctx();

    cur_b = LLVMGetInsertBlock(builder);
    cur_f = LLVMGetBasicBlockParent(cur_b);

    expr_stmt_leave_b  = LLVMAppendBasicBlockInContext(llvm_ctx, cur_f, "expr_stmt_leave_b");
    expr_stmt_leave_bv = LLVMBasicBlockAsValue(expr_stmt_leave_b);

    v_add_variable_q(voidc_internal_branch_target_leave_q, 0, expr_stmt_leave_bv);      //- Sic!


    v_ast_accept_visitor((&obj.stmt: *v_ast_base_t), vis);


    cur_b = LLVMGetInsertBlock(builder);

    if (LLVMGetBasicBlockTerminator(cur_b) == 0)
    {
        LLVMBuildBr(builder, expr_stmt_leave_b);
    }


    LLVMMoveBasicBlockAfter(expr_stmt_leave_b, cur_b);


    LLVMPositionBuilderAtEnd(builder, expr_stmt_leave_b);


    v_restore_variables();


    tr = data[0];

    if (vr_temporary)
    {
        v_save_builder_ip();

        anchor = v_load(&vr);

        LLVMPositionBuilderBefore(builder, anchor);

        vr := LLVMBuildAlloca(builder, v_type_get_llvm_type(tr), "");

        v_restore_builder_ip();

        LLVMReplaceAllUsesWith(anchor, vr);

        LLVMInstructionEraseFromParent(anchor);
    }

    if (!v_type_is_special(tr, q_initialize))
    {
        vr := LLVMBuildLoad2(builder, v_type_get_llvm_type(tr), vr, "");
    }

    v_pop_result();

    v_adopt_result(tr, vr);
}

//---------------------------------------------------------------------
private
my_break_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ctx = *(aux: *local_objects_ctx_t);

    builder = v_target_get_builder();

    call = (self: *v_ast_expr_t);

    arg_list = v_ast_expr_call_get_arg_list(call);

    args_count = v_list_get_size(arg_list);

    if (args_count)
    {
        arg0 = v_list_get_item(arg_list, 0);

        brk_type  = v_get_variable_type_q(voidc_internal_break_value_q);
        brk_value = v_get_variable_value_q(voidc_internal_break_value_q);

        data = *(brk_value: *struct { *v_type_t; LLVMValueRef; });

        v_reset_result();

        v_set_result_type(brk_type);
        v_set_result_value(data[1]);

        v_ast_accept_visitor((arg0: *v_ast_base_t), vis);

        tr = v_get_result_type();
        vr = v_get_result_value();

        if (data[0] == 0)   data[0] := tr;
        else                v_assert(data[0] == tr);

        if (!v_type_is_special(tr, q_initialize))
        {
            LLVMBuildStore(builder, vr, data[1]);
        }
    }

    stmt = v_make_object(v_ast_stmt_t);

    v_ast_make_stmt_call(stmt, 0, q_break, 0, 0);

    ctx.break(vis, (stmt: *v_ast_base_t));        //- Sic !!!
}


//---------------------------------------------------------------------
private
my_compile_op_prefix_amp_helper: (vis: *voidc_visitor_t, arg: *v_ast_expr_t, compile: *void) ~> void
{
//printf("my_compile_op_prefix_amp_helper: start\n");
//defer printf("my_compile_op_prefix_amp_helper: stop\n");

    v_push_result();

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((arg: *v_ast_base_t), vis);

    t = v_get_result_type();
    v = v_get_result_value();

    t: &*v_type_t := t;

    if (v_type_is_special(t, q_initialize))
    {
        t := v_reference_type(t, 0);            //- Sic !!!
    }

    compile = (compile: *((*voidc_visitor_t, &*v_type_t, LLVMValueRef) ~> LLVMValueRef));

    v = compile(vis, t, v);

    v_pop_result();

    v_adopt_result(t, v);
}


//=====================================================================
private
my_internal_var_defn_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_internal_var_defn_intrinsic: start\n");
//defer printf("my_internal_var_defn_intrinsic: stop\n");

    ctx = *(aux: *local_objects_ctx_t);

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    v_assert(v_get_result_type() == INVIOLABLE_TAG);

    anchor = v_get_result_value();
    v_assert(anchor);

    v_push_result();

    v_set_result_type(v_find_type_q(q_static_type_t));

    v_ast_accept_visitor((arg0: *v_ast_base_t), vis);               //- Type

    var_type = (v_get_result_value() : *v_type_t);

    v_assert(v_type_is_reference(var_type));

    t = v_type_refptr_get_element_type(var_type);       //- Sic!
    a = v_type_refptr_get_address_space(var_type);      //- Sic!


    builder = v_target_get_builder();

    llvm_ctx = v_target_get_llvm_ctx();

    v_pop_result();

    v_set_result_type(t);

    v_ast_accept_visitor((arg1: *v_ast_base_t), vis);               //- Value

    t = v_get_result_type();
    v = v_get_result_value();


    v_save_builder_ip();

    LLVMPositionBuilderBefore(builder, anchor);

    var_value = LLVMBuildAlloca(builder, v_type_get_llvm_type(t), "");


    is_special = v_type_is_special(t, q_initialize);

    if (is_special)
    {
        stmt = v_make_object(v_ast_stmt_t);

        voidc_make_special_intrinsic_call(stmt, q_initialize, t, var_value, 0);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

        if (v_type_is_special(t, q_terminate))
        {
            voidc_make_special_intrinsic_call(stmt, q_terminate, t, var_value, 0);

            v_ast_make_stmt_defer(stmt, stmt);

            v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
        }

        LLVMReplaceAllUsesWith(anchor, var_value);          //- Sic!!!
    }

    v_restore_builder_ip();


    if (!is_special)
    {
        LLVMBuildStore(builder, v, var_value);
    }

    v_set_result_type(v_reference_type(t, a));
    v_set_result_value(var_value);

    //- ?
}


//=====================================================================
private
my_op_braces_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_op_braces_intrinsic: start\n");
//defer printf("my_op_braces_intrinsic: stop\n");

    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    N = v_list_get_size(args);


    tr: &*v_type_t := v_get_result_type();


    {   ctx: &*void := v_undef();

        if (fun = v_util_lookup_overload(q_op_braces, tr, &ctx))
        {
            //- Got overloading!

            arg_ptrs = v_malloc(*v_ast_expr_t, N);
            defer v_free(arg_ptrs);

            for (i: &int := 0; i < N; ++i)
            {
                arg_ptrs[i] := v_list_get_item(args, i);
            }

            fun(ctx, vis, self, arg_ptrs, (N: unsigned));

            v_return();
        }
    }


    //- Default treatment...

    is_reference = v_type_is_reference(tr);

    addr_sp: &unsigned := v_undef();

    if (is_reference)
    {
        addr_sp := v_type_refptr_get_address_space(tr);         //- Sic!
        tr      := v_type_refptr_get_element_type(tr);          //- Sic!
    }

    block
    {
        if (!v_type_is_generic(tr))   v_break();

        if (v_type_generic_get_cons(tr) != voidc_incomplete_array_type_tag)   v_break();

        arg0 = v_type_generic_get_args(tr)[0];

        type = v_type_generic_arg_type_get_type(arg0);

        tr := v_array_type(type, N);
    }

    if (!v_type_is_special(tr, q_initialize))
    {
        if (is_reference)   tr := v_reference_type(tr, addr_sp);

        v_set_result_type(tr);

        (aux: *local_objects_ctx_t)->op_braces(vis, self);

        v_return();
    }

    vr: &LLVMValueRef := v_get_result_value();

    if (vr == 0)  vr := v_make_temporary(tr, 0);


    v_push_result();

    builder = v_target_get_builder();

    {   ets: &**v_type_t := 0;

        et: &*v_type_t := v_undef();

        if (v_type_is_struct(tr)) ets := v_type_struct_get_element_types(tr);
        if (v_type_is_array(tr))  et  := v_type_array_get_element_type(tr);

        int_ = v_type_get_llvm_type(v_find_type_q(int_q));

        val: &LLVMValueRef[2] := { LLVMConstInt(int_, 0, 0) };

        tr_ = v_type_get_llvm_type(tr);

        for (i: &int := 0; i < N; ++i)
        {
            expr = v_list_get_item(args, i);

            if (ets)  et := ets[i];

            v_reset_result();

            v_set_result_type(et);

            val[1] := LLVMConstInt(int_, i, 0);

            vr_i = LLVMBuildGEP2(builder, tr_, vr, val, 2, "");

            v_set_result_value(vr_i);

            v_ast_accept_visitor((expr: *v_ast_base_t), vis);

            if (!v_type_is_special(et, q_initialize))
            {
                LLVMBuildStore(builder, v_get_result_value(), vr_i);
            }
        }
    }

    v_pop_result();

    if (is_reference) v_set_result_type(v_reference_type(tr, addr_sp));
    else              v_set_result_type(tr);

    v_set_result_value(vr);
}


//---------------------------------------------------------------------
private
my_compute_key_quark_type: (aux: *void,
                            ft: *v_type_t, q: &v_quark_t
                           ) ~> *v_type_t
{
//printf("my_compute_key_quark_type: start\n");
//defer printf("my_compute_key_quark_type: stop\n");

    if (q == q_op_braces)
    {
        v_return(v_type_function_get_return_type(ft));
    }

    ctx = *(aux: *my_compute_key_quark_type_t);

    v_return(ctx.fun(ctx.aux, ft, q));
}


//---------------------------------------------------------------------
private
my_op_postfix_index_helper: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                             agg_t: &*v_type_t, agg_v: &LLVMValueRef,
                             idx: **v_ast_expr_list_t, count: unsigned
                            ) ~> bool
{
    if (v_type_is_special(agg_t, q_initialize))
    block
    {
        q = q_op_postfix_index;

        if (v_util_lookup_overload(q, agg_t, 0))  v_break();

        agg_t := v_reference_type(agg_t, 0);            //- Sic !?!?!?!?!?!?!?!
    }

    ctx = *(aux: *op_postfix_index_helper_ctx_t);

    v_return(ctx.fun(ctx.aux, vis, self, agg_t, agg_v, idx, count));
}


//=====================================================================
//- Enable local objects
//---------------------------------------------------------------------
export
voidc_enable_local_objects_compiler: () ~> void
{
    v_return_if(v_find_constant_q(enabled_q, 0, 0));

    v_add_constant_q(enabled_q, v_void_type(), 0);

    //-----------------------------------------------------------------
    v_type_set_obtain_llvm_type_hook(v_type_kind_function, my_type_function_obtain_llvm_type, 0);

    //-----------------------------------------------------------------
    ctx = *v_malloc(local_objects_ctx_t);

    free: (*void) ~> void;

    v_add_local_cleaner(free, &ctx);

    //-----------------------------------------------------------------
    ctx.fun_params.fun := v_get_prepare_function_parameters_hook(&ctx.fun_params.aux);

    v_set_prepare_function_parameters_hook(my_prepare_function_parameters, &ctx);

    //-----------------------------------------------------------------
    ctx.cleaners_stack := 0;

    //-----------------------------------------------------------------
    ctx.push_temporaries.fun := v_get_push_temporaries_hook(&ctx.push_temporaries.aux);
    ctx.pop_temporaries.fun  := v_get_pop_temporaries_hook (&ctx.pop_temporaries.aux);
    ctx.make_temporary.fun   := v_get_make_temporary_hook  (&ctx.make_temporary.aux);

    v_set_push_temporaries_hook(my_push_temporaries, &ctx);
    v_set_pop_temporaries_hook (my_pop_temporaries,  &ctx);
    v_set_make_temporary_hook  (my_make_temporary,   &ctx);

    v_set_handler(v_add_temporary_cleaner, add_temporary_cleaner_helper, &ctx);

    //-----------------------------------------------------------------
    vis = v_get_compiler();

    q = v_quark_from_string;

    stmt_q = q("stmt");

    ctx.compile_stmt.fun := voidc_visitor_get_method(vis, stmt_q, &ctx.compile_stmt.aux);

    voidc_visitor_set_method(vis, vis, stmt_q, my_compile_stmt, &ctx);

    //-----------------------------------------------------------------
    ctx.try_to_adopt.fun   := v_get_try_to_adopt_hook  (&ctx.try_to_adopt.aux);
    ctx.try_to_convert.fun := v_get_try_to_convert_hook(&ctx.try_to_convert.aux);

    v_set_try_to_adopt_hook  (my_try_to_adopt,   &ctx);
    v_set_try_to_convert_hook(my_try_to_convert, &ctx);

    //-----------------------------------------------------------------
    v_set_handler(v_llvm_build_call, my_llvm_build_call, &ctx);

    //-----------------------------------------------------------------
    q_return = q("v_return");

    ctx.return.fun := (v_get_intrinsic_q(q_return, &ctx.return.aux) : *voidc_intrinsic_t);
    ctx.break.fun  := (v_get_intrinsic_q(q_break,  &ctx.break.aux)  : *voidc_intrinsic_t);

    v_add_intrinsic_q(q_return, my_return_intrinsic, &ctx);
    v_add_intrinsic_q(q_break,  my_break_intrinsic,  &ctx);

    //-----------------------------------------------------------------
    expr_stmt_q  = q("expr_stmt");

    voidc_visitor_set_method(vis, vis, expr_stmt_q,  my_compile_expr_stmt, 0);

    //-----------------------------------------------------------------
    {   aux: &*void := v_undef();

        amp_q  = q("voidc.expression_helper_prefix_amp");

        v_get_intrinsic_q(amp_q, &aux);

        v_add_intrinsic_q(amp_q, my_compile_op_prefix_amp_helper, aux);
    }

    //-----------------------------------------------------------------
    v_add_intrinsic_q(q("v.internal.var_defn"), my_internal_var_defn_intrinsic, &ctx);

    //-----------------------------------------------------------------
    ctx.op_braces.fun := (v_get_intrinsic_q(q_op_braces, &ctx.op_braces.aux) : *voidc_intrinsic_t);

    v_add_intrinsic_q(q_op_braces, my_op_braces_intrinsic, &ctx);

    //-----------------------------------------------------------------
    ctx.key_quark.fun := v_get_handler(v_compute_key_quark_type, &ctx.key_quark.aux);

    v_set_handler(v_compute_key_quark_type, my_compute_key_quark_type, &ctx.key_quark);

    //-----------------------------------------------------------------
    ctx.op_index.fun := v_get_handler(v_compile_op_postfix_index, &ctx.op_index.aux);

    v_set_handler(v_compile_op_postfix_index, my_op_postfix_index_helper, &ctx.op_index);
}

//---------------------------------------------------------------------
//- Enable local objects
//---------------------------------------------------------------------
export
voidc_enable_local_objects: () ~> void
{
    voidc_enable_local_objects_compiler();

    //- ...
}


//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   my_fake_utility_intrinsic_ctor();
}


//=====================================================================
{   voidc_enable_local_objects(); }



//---------------------------------------------------------------------
{
    printf("hello\n");
}


//---------------------------------------------------------------------
//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
alwaysinline
foo: (s: *const char) ~> v_std_string_t
{
    str = v_make_object(v_std_string_t);

    v_std_string_set(str, s);

    v_return(*str);
}

alwaysinline
bar: (str: &v_std_string_t) ~> void
{
    printf("hi: %s\n", v_std_string_get(&str));
}


{
    s = foo("qwe");

    bar(s);
}


{
    bar(foo("asd"));
}


//---------------------------------------------------------------------
alwaysinline
baz: (s0: v_std_string_t, s1: *const char) ~> v_std_string_t
{
    str = v_make_object(v_std_string_t);

    v_std_string_set(str, v_std_string_get(&s0));

    v_std_string_append(str, s1);

    v_return(*str);
}

//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
{
    v = foo("zxc");
    v = baz(v, "_qaz");
    v = baz(baz(v, "_wsx"), "_edc");
    v = baz(baz(baz(v, "_rfv"), "_tgb"), "_yhn");

    bar(v);
}


//---------------------------------------------------------------------
//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
{
    printf("aaa\n");

    str = block
    {
        v = foo("zxc");

//      v_break(v);

        v_break(baz(v, "_qaz"));
    };

    bar(str);
}


//---------------------------------------------------------------------
(_+_): (a: v_std_string_t, b: v_std_string_t) ~> v_std_string_t
{
    r = &v_get_return_value();

    v_std_string_set(r, v_std_string_get(&a));

    v_std_string_append(r, v_std_string_get(&b));
}

//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
{
    str = foo("qaz") + foo("_wsx") + foo("_edc");

    bar(str + foo("/") + str);

}


//---------------------------------------------------------------------
(_<<_): (a: &v_std_string_t, b: v_std_string_t) ~> &v_std_string_t
{
    v_std_string_append(&a, v_std_string_get(&b));

    v_return(a);
}

(_*_): (a: v_std_string_t, n: unsigned) ~> v_std_string_t
{
    a = v_std_string_get(&a);

    r = &v_get_return_value();

    v_std_string_set(r, "");

    for (i: &unsigned := 0; i < n; ++i)
    {
        v_std_string_append(r, a);
    }
}

{
    s = { a = foo("A"); a = a + foo("_B");  a = a + foo("_C"); a };

    bar(s + foo("_D"));

    s = *v_make_object(v_std_string_t);

    v_std_string_set(&s, "W");

    s << foo("_X")
      << foo("_Y")
      << foo("_Z");

    bar(s);

    bar(foo("~>") * 10);

}


//---------------------------------------------------------------------
{
    str: &v_std_string_t := foo("qwerty");

    bar(str);

    str << foo("!!!");

    bar(str);

}


//---------------------------------------------------------------------
{
    str: v_std_string_t = foo("qwerty") + foo("...");

    bar(str);

}


//---------------------------------------------------------------------
{
    str: &v_std_string_t[] := { foo("qwe"), foo("asd"), foo("zxc") };

    for (i: &int := 0; i < 3; ++i)  str[i] << foo("?");

    for (i: &int := 0; i < 3; ++i)  bar(str[i]);

    s: &v_std_string_t := {};

    v_std_string_set(&s, "W");

    s << foo("_X")
      << foo("_Y")
      << foo("_Z");

    bar(s);

}


//---------------------------------------------------------------------
dump_module_intrinsic: (*void, *voidc_visitor_t, *v_ast_base_t) ~> void
{
    m = v_get_module();

    LLVMDumpModule(m);
}

{   v_add_intrinsic("dump_module", dump_module_intrinsic, 0); }


//---------------------------------------------------------------------
//{ voidc_verify_jit_module_optimized(true); }
//{ v_debug_print_module(9); }
{
    printf("\n");

    s: &v_std_string_t :=
    {
        ss: &v_std_string_t := {};

        v_std_string_set(&ss, "qwe ------------------------------------------------------------->");

        ss
    };

//    s: &v_std_string_t := block
//    {
//        ss: &v_std_string_t := {};
//
//        v_std_string_set(&ss, "qwe");
//
//        v_break(ss);
//    };

    printf("s: %s\n", v_std_string_get(&s));

    x: &int := block { v_break(42); };

    printf("x: %d\n", x);

    y: int = block { v_break(99); };

    printf("y: %d\n", y);

    z: int = block { v_break(77); } + 11;

    printf("z: %d\n", z);

    xx: &int := { a: &int := 1; a += 2; a+3 };

    printf("xx: %d\n", xx);

    u: &int[2] := block { v_break({7, 77}); };

    printf("u: (%d, %d)\n", u[0], u[1]);

    v: vec(int, 2) = block { v_break({8, 88}); };

    printf("v: [%d, %d]\n", v[0], v[1]);
}


//=====================================================================
{   v_import("level-03/intrinsics_derive.void"); }
{   voidc_enable_intrinsics_derive(); }


//=====================================================================
//- test_t ...
//=====================================================================
test_t = struct { v_std_any_t; };

{   f = v_type_is_special(test_t, v_quark_from_string("v_initialize"));

    printf("f: %d\n", (f: int));
}

(v_initialize(_)): (*test_t, size_t) ~> void = derive;
(v_terminate(_)):  (*test_t, size_t) ~> void = derive;

(v_copy(_)): (*test_t, *const test_t, size_t) ~> void = derive;

//{ v_debug_print_module(1); }
{
    u: &test_t[2][3][4] := {};

    U = *v_malloc(test_t[7]) := 0;

    v_free(&U);
}


//=====================================================================
//- v_ast ...
//=====================================================================
{   voidc_unit_begin_module("local_obj_ast_test_module"); }

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));

    v_set_export_flag(true);
}

//---------------------------------------------------------------------
//{ v_debug_print_module(1); }


//---------------------------------------------------------------------
mk_expr_identifier: (id: *const char) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_identifier(&ret, id);
}

//---------------------------------------------------------------------
mk_expr_integer: (num: intptr_t) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_integer(&ret, num);
}

//---------------------------------------------------------------------
mk_expr_string: (str: *const char) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_string(&ret, str);
}

//---------------------------------------------------------------------
mk_expr_char: (c: char32_t) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_char(&ret, c);
}


//---------------------------------------------------------------------
mk_expr_compiled: (t: *v_type_t, v: LLVMValueRef) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_compiled(&ret, t, v);
}


//---------------------------------------------------------------------
mk_expr_call: (fun: v_ast_expr_t, args: v_ast_expr_list_t) ~> v_ast_expr_t
{
    ret = v_get_return_value();

    v_ast_make_expr_call(&ret, &fun, &args);
}


//---------------------------------------------------------------------
mk_stmt: (name: *const char, expr: v_ast_expr_t) ~> v_ast_stmt_t
{
    ret = v_get_return_value();

    v_ast_make_stmt(&ret, name, &expr);
}


//---------------------------------------------------------------------
private
mk_ast_list_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("mk_ast_list_intrinsic: start\n");
//defer printf("mk_ast_list_intrinsic: stop\n");

//    ttag = v_get_result_type();
//    vtag = v_get_result_value();

    tr = (aux: *v_type_t);

    vr: &LLVMValueRef := v_get_result_value();

    vr_temporary = vr == 0;

    if (vr_temporary)
    {
        vr := v_make_temporary(tr, 0);
    }

    is_generic = tr == v_find_type("v_ast_generic_list_t");


    v_push_result();


    builder = v_target_get_builder();

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    args_count = v_list_get_size(arg_list) - (is_generic: size_t);

    if (args_count == 0)
    {
        expr = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        list: &v_ast_expr_list_t := {};

        v_make_list(&list, &expr, 1);

        if (is_generic) v_list_append(&list, &list, v_list_get_item(arg_list, 0));

        e = mk_expr_call(mk_expr_identifier("v_make_list_nil"), list);

        v_ast_accept_visitor((&e: *v_ast_base_t), vis);

        v_pop_result();

        v_adopt_result(tr, vr);

        v_return();
    }


    item_t: &*v_type_t := v_undef();

    if (is_generic)
    {
        item_t := v_find_type("v_ast_base_t");
    }
    else if (tr == v_find_type("v_ast_expr_list_t"))
    {
        item_t := v_find_type("v_ast_expr_t");
    }
    else if (tr == v_find_type("v_ast_stmt_list_t"))
    {
        item_t := v_find_type("v_ast_stmt_t");
    }


    lltyp: &LLVMTypeRef :=  v_undef();

    llvm_stacksave_f = v_obtain_function(voidc_llvm_stacksave_name, &lltyp);

    blk = LLVMBuildCall2(builder, lltyp, llvm_stacksave_f, 0, 0, "blk");


    expr: &v_ast_expr_t[2] := {};

    stmt: &v_ast_stmt_t := {};


    size_t_ = v_type_get_llvm_type(size_t);

    args_count_ = LLVMConstInt(size_t_, args_count, 0);

    item_t_ = v_type_get_llvm_type(item_t);

    buf_v = LLVMBuildArrayAlloca(builder, item_t_, args_count_, "buf_v");


    v_ast_make_expr_compiled(expr+0, v_pointer_type(item_t, 0), buf_v);

    v_ast_make_expr_integer(expr+1, args_count);

    v_ast_make_stmt_call(&stmt, 0, q_initialize, expr, 2);

    v_ast_accept_visitor((&stmt: *v_ast_base_t), vis);


    for (i: &int := 0; i < args_count; ++i)
    {
        i_ = LLVMConstInt(size_t_, i, 0);

        ei = LLVMBuildGEP2(builder, item_t_, buf_v, &i_, 1, "ei");

        v_set_result_type(item_t);
        v_set_result_value(ei);

        expr = v_list_get_item(arg_list, i+(is_generic: int));

        v_ast_accept_visitor((expr: *v_ast_base_t), vis);
    }


    {   expr = mk_expr_compiled(v_pointer_type(tr, 0), vr);

        list: &v_ast_expr_list_t := {};

        v_make_list(&list, &expr);

        if (is_generic) v_list_append(&list, &list, v_list_get_item(arg_list, 0));

        expr = mk_expr_compiled(v_pointer_type(v_ast_expr_t, 0), buf_v);

        v_list_append(&list, &list, &expr);

        expr = mk_expr_integer(args_count);

        v_list_append(&list, &list, &expr);

        expr = mk_expr_call(mk_expr_identifier("v_make_list"), list);

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor((&expr: *v_ast_base_t), vis);
    }


    {   expr: &v_ast_expr_t[2] := {};

        stmt: &v_ast_stmt_t := {};

        v_ast_make_expr_compiled(expr+0, v_pointer_type(item_t, 0), buf_v);

        v_ast_make_expr_integer(expr+1, args_count);

        v_ast_make_stmt_call(&stmt, 0, q_terminate, expr, 2);

        v_ast_accept_visitor((&stmt: *v_ast_base_t), vis);
    }


    llvm_stackrestore_f = v_obtain_function(voidc_llvm_stackrestore_name, &lltyp);

    LLVMBuildCall2(builder, lltyp, llvm_stackrestore_f, &blk, 1, "");


    v_pop_result();

    v_adopt_result(tr, vr);
}


//---------------------------------------------------------------------
(_:=_): (p: &v_ast_expr_t, v: v_ast_expr_t) ~> &v_ast_expr_t
{
    v_copy(&p, &v);

    v_return(p);
}

(_:=_): (p: &v_ast_expr_list_t, v: v_ast_expr_list_t) ~> &v_ast_expr_list_t
{
    v_copy(&p, &v);

    v_return(p);
}

(_:=_): (p: &v_ast_stmt_t, v: v_ast_stmt_t) ~> &v_ast_stmt_t
{
    v_copy(&p, &v);

    v_return(p);
}

(_:=_): (p: &v_ast_stmt_list_t, v: v_ast_stmt_list_t) ~> &v_ast_stmt_list_t
{
    v_copy(&p, &v);

    v_return(p);
}

(_:=_): (p: &v_ast_base_t, v: v_ast_base_t) ~> &v_ast_base_t
{
    v_copy(&p, &v);

    v_return(p);
}

(_:=_): (p: &v_ast_generic_list_t, v: v_ast_generic_list_t) ~> &v_ast_generic_list_t
{
    v_copy(&p, &v);

    v_return(p);
}

//---------------------------------------------------------------------
(_+=_): (l: &v_ast_expr_list_t, e: v_ast_expr_t) ~> &v_ast_expr_list_t
{
    v_list_append(&l, &l, &e);

    v_return(l);
}

(_+=_): (l: &v_ast_stmt_list_t, s: v_ast_stmt_t) ~> &v_ast_stmt_list_t
{
    v_list_append(&l, &l, &s);

    v_return(l);
}

(_+=_): (l: &v_ast_generic_list_t, s: v_ast_base_t) ~> &v_ast_generic_list_t
{
    v_list_append(&l, &l, &s);

    v_return(l);
}


//---------------------------------------------------------------------
enable_local_obj_ast_test: () ~> void
{
    v_add_intrinsic("mk_expr_list",    mk_ast_list_intrinsic, v_find_type("v_ast_expr_list_t"));
    v_add_intrinsic("mk_stmt_list",    mk_ast_list_intrinsic, v_find_type("v_ast_stmt_list_t"));
    v_add_intrinsic("mk_generic_list", mk_ast_list_intrinsic, v_find_type("v_ast_generic_list_t"));
}


//{ v_debug_print_module(2); }
//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   enable_local_obj_ast_test();
}


//---------------------------------------------------------------------
//{ v_debug_print_module(1); }
{
    e = mk_expr_call(mk_expr_identifier("fun"), mk_expr_list());

//    a = mk_expr_identifier("a");
//    b = mk_expr_identifier("b");
//    c = mk_expr_identifier("c");
//
//    l = mk_expr_list(a, b, c);

    l = mk_expr_list
    (
        mk_expr_identifier("a"),
        mk_expr_identifier("b"),
        mk_expr_identifier("c")
    );

    f = mk_expr_call
    (
        mk_expr_identifier("foo"),
        mk_expr_list
        (
            mk_expr_integer(42),
            mk_expr_identifier("v"),
            mk_expr_call
            (
                mk_expr_identifier("bar"),
                mk_expr_list
                (
                    mk_expr_identifier("baz")
                )
            )
        )
    );
}


//---------------------------------------------------------------------
//{   v_debug_print_module(1);
//
////  voidc_verify_jit_module_optimized(true);
//}
{
    e: &v_ast_expr_t := mk_expr_identifier("foo");

    printf("e: %p[%p, %p]\n", &e, (e[0][0]: *void), (e[0][1]: *void));

    l: &v_ast_expr_list_t := mk_expr_list();

    l += mk_expr_identifier("a");
    l += mk_expr_identifier("b");
    l += mk_expr_identifier("c");

    e := mk_expr_call(e, l);


    printf("e: %p[%p, %p]\n", &e, (e[0][0]: *void), (e[0][1]: *void));

    f = *v_ast_expr_call_get_fun_expr(&e);

    printf("f: %p[%p, %p]\n", &f, (f[0][0]: *void), (f[0][1]: *void));


    s: v_ast_expr_t = mk_expr_string("qwerty");

}


//---------------------------------------------------------------------
//{   v_debug_print_module(1); }
{
    e: &v_ast_expr_t[] :=
    {
        mk_expr_identifier("foo"),
        mk_expr_integer(777),
        mk_expr_char('Ы'),
    };

    f: &v_ast_expr_t := {};


}


//---------------------------------------------------------------------
//{   v_debug_print_module(2);
//
//    voidc_verify_jit_module_optimized(true);
//}

(_[]): (l: v_ast_expr_list_t, i: size_t) ~> v_ast_expr_t
=
    *v_list_get_item(&l, i);

(_[]): (l: &v_ast_expr_list_t, i: size_t) ~> &v_ast_expr_t
=
    *v_list_get_item(&l, i);


//---------------------------------------------------------------------
//{   v_debug_print_module(2);
//
//    voidc_verify_jit_module_optimized(true);
//}

{
    e: &v_ast_expr_t[3] := {};

    e[0] := mk_expr_identifier("foo");
    e[1] := mk_expr_integer(777);
    e[2] := mk_expr_char('Ы');

    l: &v_ast_expr_list_t := {};

    v_make_list(&l, e, 3);

    v_ast_make_expr_call(&e[0], &e[0], &l);

    ef = v_ast_expr_call_get_fun_expr(&e[0]);

    name = v_ast_expr_identifier_get_name(ef);

    printf("fun_name: %s\n", name);
}








