{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");
}

{   v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();
}


//---------------------------------------------------------------------
double = float(64);

abs: (double) -> double;

snprintf: (s: *char, l: size_t, f: *const char, ...) -> int;

sin: (double) -> double;
cos: (double) -> double;

M_PI = 3.14159265358979323846264338327950288419716939937510582;


//---------------------------------------------------------------------
EPSILON = 1e-9;

is_equal: (x: double, y: double) -> bool
{
    if (x == y)  v_return(true);

    size = abs(x) + abs(y);

    if (size <= EPSILON)  v_return(true);

    diff = abs(x - y);

    if (diff <= EPSILON)  v_return(true);

    if (size > 1  &&  diff/size <= EPSILON)  v_return(true);

    v_return(false);
}

is_finite: (x: double) -> bool
{
    v_return(abs(x) < 1e15);        //- ?...
}

infinity = 1e1000;

det_3: (v: &double[9]) -> double
{
    v00 = v[0]; v01 = v[1]; v02 = v[2];
    v10 = v[3]; v11 = v[4]; v12 = v[5];
    v20 = v[6]; v21 = v[7]; v22 = v[8];

    v_return( v00 * (v11*v22 - v12*v21)
            - v10 * (v01*v22 - v02*v21)
            + v20 * (v01*v12 - v02*v11) );
}


//---------------------------------------------------------------------
seq_equal: (a: *double, b: *double, n: int) -> bool
{
    ret: &bool := true;

    for (i: &int := 0; i < n; ++i)  if (!is_equal( a[i], b[i]))  { ret := false;  v_break(); }

    if (ret)  v_return(true);

    ret := true;

    for (i: &int := 0; i < n; ++i)  if (!is_equal(-a[i], b[i]))  { ret := false;  v_break(); }

    v_return(ret);
}


//=====================================================================
//- Vector (2D)
//=====================================================================
struct Vector
{
    x: double;
    y: double;
};

//---------------------------------------------------------------------
Vector_op_infix_shl_right: (s: &v_std_string_ptr, v: &Vector) -> &v_std_string_ptr
{
    n = 1 + snprintf(0, 0, "(%g, %g)", v.x, v.y);

    buf = v_alloca(char, n);

    snprintf(buf, n, "(%g, %g)", v.x, v.y);

    v_std_string_append(s, buf);
}

{   Vector_ref = v_reference_type(Vector, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_shl.right"), Vector,     "Vector_op_infix_shl_right");
    v_util_function_dict_set(q("op_infix_shl.right"), Vector_ref, "Vector_op_infix_shl_right");
}

//---------------------------------------------------------------------
Vector_op_infix_add: (a: &Vector, b: &Vector) -> Vector
{
    v_return({ a.x+b.x, a.y+b.y });
}

Vector_op_infix_sub: (a: &Vector, b: &Vector) -> Vector
{
    v_return({ a.x-b.x, a.y-b.y });
}

Vector_op_prefix_plus: (a: &Vector) -> Vector
{
    v_return(a);
}

Vector_op_prefix_minus: (a: &Vector) -> Vector
{
    v_return({ -a.x, -a.y });
}

Vector_op_infix_mul: (a: &Vector, k: double) -> Vector
{
    v_return({ a.x*k, a.y*k });
}

Vector_op_infix_mul_right: (k: double, a: &Vector) -> Vector
{
    v_return({ k*a.x, k*a.y });
}

Vector_op_infix_div: (a: &Vector, k: double) -> Vector
{
    v_return({ a.x/k, a.y/k });
}

Vector_op_infix_eq: (a: &Vector, b: &Vector) -> bool
{
    v_return( is_equal(a.x, b.x)  &&  is_equal(a.y, b.y) );
}

Vector_op_infix_ne: (a: &Vector, b: &Vector) -> bool
{
    v_return( !Vector_op_infix_eq(a, b) );
}

{   Vector_ref = v_reference_type(Vector, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_add"),       Vector, "Vector_op_infix_add");
    v_util_function_dict_set(q("op_infix_sub"),       Vector, "Vector_op_infix_sub");
    v_util_function_dict_set(q("op_infix_mul"),       Vector, "Vector_op_infix_mul");
    v_util_function_dict_set(q("op_infix_mul.right"), Vector, "Vector_op_infix_mul_right");
    v_util_function_dict_set(q("op_infix_div"),       Vector, "Vector_op_infix_div");
    v_util_function_dict_set(q("op_infix_eq"),        Vector, "Vector_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"),        Vector, "Vector_op_infix_ne");

    v_util_function_dict_set(q("op_infix_add"),       Vector_ref, "Vector_op_infix_add");
    v_util_function_dict_set(q("op_infix_sub"),       Vector_ref, "Vector_op_infix_sub");
    v_util_function_dict_set(q("op_infix_mul"),       Vector_ref, "Vector_op_infix_mul");
    v_util_function_dict_set(q("op_infix_mul.right"), Vector_ref, "Vector_op_infix_mul_right");
    v_util_function_dict_set(q("op_infix_div"),       Vector_ref, "Vector_op_infix_div");
    v_util_function_dict_set(q("op_infix_eq"),        Vector_ref, "Vector_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"),        Vector_ref, "Vector_op_infix_ne");
}

//---------------------------------------------------------------------
Vector_zero:     Vector = {0, 0};
Vector_unit_x:   Vector = {1, 0};
Vector_unit_y:   Vector = {0, 1};
Vector_infinity: Vector = {infinity, infinity};

//---------------------------------------------------------------------
Vector_dot: (a: &Vector, b: &Vector) -> double
{
    v_return( a.x*b.x + a.y*b.y );
}

Vector_crs: (a: &Vector, b: &Vector) -> double
{
    v_return( a.x*b.y - a.y*b.x );
}

Vector_is_fininite: (a: &Vector) -> bool
{
    v_return( is_finite(a.x)  &&  is_finite(a.y) );
}

{   Vector_ref = v_reference_type(Vector, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".dot()"),       Vector, "Vector_dot");
    v_util_function_dict_set(q(".crs()"),       Vector, "Vector_dot");
    v_util_function_dict_set(q(".is_finite()"), Vector, "Vector_is_finite");

    v_util_function_dict_set(q(".dot()"),       Vector_ref, "Vector_dot");
    v_util_function_dict_set(q(".crs()"),       Vector_ref, "Vector_dot");
    v_util_function_dict_set(q(".is_finite()"), Vector_ref, "Vector_is_finite");
}


//=====================================================================
//- Projective point (2D)
//=====================================================================
struct Point
{
    x: double;
    y: double;
    w: double;
};

//---------------------------------------------------------------------
Point_op_infix_shl_right: (s: &v_std_string_ptr, p: &Point) -> &v_std_string_ptr
{
    n = 1 + snprintf(0, 0, "(%g, %g, %g)", p.x, p.y, p.w);

    buf = v_alloca(char, n);

    snprintf(buf, n, "(%g, %g, %g)", p.x, p.y, p.w);

    v_std_string_append(s, buf);
}

{   Point_ref = v_reference_type(Point, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_shl.right"), Point,     "Point_op_infix_shl_right");
    v_util_function_dict_set(q("op_infix_shl.right"), Point_ref, "Point_op_infix_shl_right");
}

//---------------------------------------------------------------------
Point_op_infix_add: (p: &Point, v: &Vector) -> Point
{
    v_return({ p.x + p.w*v.x, p.y + p.w*v.y, p.w });
}

Point_op_infix_sub: (a: &Point, b: &Point) -> Vector
{
    v_return({ a.x/a.w - b.x/b.w, a.y/a.w - b.y/b.w });
}

{   Point_ref = v_reference_type(Point, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_add"), Point, "Point_op_infix_add");
    v_util_function_dict_set(q("op_infix_sub"), Point, "Point_op_infix_sub");

    v_util_function_dict_set(q("op_infix_add"), Point_ref, "Point_op_infix_add");
    v_util_function_dict_set(q("op_infix_sub"), Point_ref, "Point_op_infix_sub");
}

//---------------------------------------------------------------------
Point_norm: (p: &Point) -> bool
{
    pa: &double[3] := {p.x, p.y, p.w};

    d: &double := 0;

    for (i: &int := 0; i < 3; ++i)
    {
        if (!is_finite(pa[i]))  v_return(false);

        if (di = abs(pa[i]), d < di)  d := di;
    }

    if (d == 0)  v_return(false);
    if (d == 1)  v_return(true);

    p.x /= d;
    p.y /= d;
    p.w /= d;

    v_return(true);
}

{   Point_ref = v_reference_type(Point, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".norm()"), Point_ref, "Point_norm");
    v_util_function_dict_set(q(".norm()"), Point,     "Point_norm");
}

//---------------------------------------------------------------------
Point_is_affine: (p: &Point) -> bool
{
    if (!p.norm())  v_return(false);

    v_return( abs(p.w) > EPSILON );
}

{   Point_ref = v_reference_type(Point, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".is_affine()"), Point_ref, "Point_is_affine");
    v_util_function_dict_set(q(".is_affine()"), Point,     "Point_is_affine");
}

//---------------------------------------------------------------------
Point_op_infix_eq: (a: &Point, b: &Point) -> bool
{
    if (!(a.norm()  &&  b.norm()))  v_return(false);

    sa: &double[] := {a.x, a.y, a.w};
    sb: &double[] := {b.x, b.y, b.w};

    v_return(seq_equal(sa, sb, 3));
}

Point_op_infix_ne: (a: &Point, b: &Point) -> bool
{
    v_return(!Point_op_infix_eq(a, b));
}

{   Point_ref = v_reference_type(Point, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_eq"), Point_ref, "Point_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Point_ref, "Point_op_infix_ne");
    v_util_function_dict_set(q("op_infix_eq"), Point,     "Point_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Point,     "Point_op_infix_ne");
}

//---------------------------------------------------------------------
Point_zero:   Point = {0, 0, 1};
Point_unit_x: Point = {1, 0, 1};
Point_unit_y: Point = {0, 1, 1};
Point_inf_x:  Point = {1, 0, 0};
Point_inf_y:  Point = {0, 1, 0};


//=====================================================================
//- Projective line (2D)
//=====================================================================
struct Line
{
    cx: double;
    cy: double;
    cw: double;
};

//---------------------------------------------------------------------
Line_op_infix_shl_right: (s: &v_std_string_ptr, l: &Line) -> &v_std_string_ptr
{
    n = 1 + snprintf(0, 0, "(%g, %g, %g)", l.cx, l.cy, l.cw);

    buf = v_alloca(char, n);

    snprintf(buf, n, "(%g, %g, %g)", l.cx, l.cy, l.cw);

    v_std_string_append(s, buf);
}

{   Line_ref = v_reference_type(Line, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_shl.right"), Line,     "Line_op_infix_shl_right");
    v_util_function_dict_set(q("op_infix_shl.right"), Line_ref, "Line_op_infix_shl_right");
}

//---------------------------------------------------------------------
Line_op_infix_add: (l: &Line, v: &Vector) -> Line
{
    v_return({ l.cx, l.cy, l.cw - l.cx*v.x - l.cy*v.y });
}

{   Line_ref = v_reference_type(Line, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_add"), Line,     "Line_op_infix_add");
    v_util_function_dict_set(q("op_infix_add"), Line_ref, "Line_op_infix_add");
}

//---------------------------------------------------------------------
Line_norm: (l: &Line) -> bool
{
    la: &double[3] := {l.cx, l.cy, l.cw};

    d: &double := 0;

    for (i: &int := 0; i < 3; ++i)
    {
        if (!is_finite(la[i]))  v_return(false);

        if (di = abs(la[i]), d < di)  d := di;
    }

    if (d == 0)  v_return(false);
    if (d == 1)  v_return(true);

    l.cx /= d;
    l.cy /= d;
    l.cw /= d;

    v_return(true);
}

{   Line_ref = v_reference_type(Line, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".norm()"), Line_ref, "Line_norm");
    v_util_function_dict_set(q(".norm()"), Line,     "Line_norm");
}

//---------------------------------------------------------------------
Line_is_affine: (l: &Line) -> bool
{
    if (!l.norm())  v_return(false);

    v_return( abs(l.cx) > EPSILON  ||  abs(l.cy) > EPSILON );
}

{   Line_ref = v_reference_type(Line, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".is_affine()"), Line_ref, "Line_is_affine");
    v_util_function_dict_set(q(".is_affine()"), Line,     "Line_is_affine");
}

//---------------------------------------------------------------------
Line_op_infix_eq: (a: &Line, b: &Line) -> bool
{
    if (!(a.norm()  &&  b.norm()))  v_return(false);

    sa: &double[] := {a.cx, a.cy, a.cw};
    sb: &double[] := {b.cx, b.cy, b.cw};

    v_return(seq_equal(sa, sb, 3));
}

Line_op_infix_ne: (a: &Line, b: &Line) -> bool
{
    v_return(!Line_op_infix_eq(a, b));
}

{   Line_ref = v_reference_type(Line, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_eq"), Line_ref, "Line_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Line_ref, "Line_op_infix_ne");
    v_util_function_dict_set(q("op_infix_eq"), Line,     "Line_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Line,     "Line_op_infix_ne");
}

//---------------------------------------------------------------------
Line_infinity: Line = {0, 0, 1};
Line_abscissa: Line = {0, 1, 0};
Line_ordinate: Line = {1, 0, 0};


//=====================================================================
incident: (l: &Line, p: &Point) -> bool
{
    l.norm();
    p.norm();

    v_return( abs(l.cx*p.x + l.cy*p.y + l.cw*p.w) < EPSILON );
}

//---------------------------------------------------------------------
Point_op_infix_and: (a: &Point, b: &Point) -> Line
{
    v_return({a.y*b.w - a.w*b.y, a.w*b.x - a.x*b.w, a.x*b.y - a.y*b.x});
}

Line_op_infix_and: (a: &Line, b: &Line) -> Point
{
    v_return({a.cy*b.cw - a.cw*b.cy, a.cw*b.cx - a.cx*b.cw, a.cx*b.cy - a.cy*b.cx});
}

{   Point_ref = v_reference_type(Point, 0);
    Line_ref  = v_reference_type(Line,  0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_and"), Point_ref, "Point_op_infix_and");
    v_util_function_dict_set(q("op_infix_and"), Line_ref,  "Line_op_infix_and");
    v_util_function_dict_set(q("op_infix_and"), Point,     "Point_op_infix_and");
    v_util_function_dict_set(q("op_infix_and"), Line,      "Line_op_infix_and");
}


//=====================================================================
//- Projective transformation (2D)
//=====================================================================
Transform = v_struct("Transform2D", { double[9] });

//---------------------------------------------------------------------
Transform_op_infix_shl_right: (s: &v_std_string_ptr, t: &Transform) -> &v_std_string_ptr
{
    t = t[0];

    n = 1 + snprintf(0, 0, "(%g, %g, %g, %g, %g, %g, %g, %g, %g)", t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);

    buf = v_alloca(char, n);

    snprintf(buf, n, "(%g, %g, %g, %g, %g, %g, %g, %g, %g)", t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);

    v_std_string_append(s, buf);
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_shl.right"), Transform,     "Transform_op_infix_shl_right");
    v_util_function_dict_set(q("op_infix_shl.right"), Transform_ref, "Transform_op_infix_shl_right");
}

//---------------------------------------------------------------------
Transform_norm: (t: &Transform) -> bool
{
    t = t[0];

    d: &double := 0;

    for (i: &int := 0; i < 9; ++i)
    {
        if (!is_finite(t[i]))  v_return(false);

        if (di = abs(t[i]), d < di)  d := di;
    }

    if (d == 0)  v_return(false);
    if (d == 1)  v_return(true);

    for (i: &int := 0; i < 9; ++i)
    {
        t[i] /= d;
    }

    v_return(true);
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".norm()"), Transform_ref, "Transform_norm");
    v_util_function_dict_set(q(".norm()"), Transform,     "Transform_norm");
}

//---------------------------------------------------------------------
Transform_det: (t: &Transform) -> double
{
    v_return( det_3(t[0]) );
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".det()"), Transform_ref, "Transform_det");
    v_util_function_dict_set(q(".det()"), Transform,     "Transform_det");
}

//---------------------------------------------------------------------
Transform_is_regular: (t: &Transform) -> bool
{
    if (!t.norm())  v_return(false);

    v_return( abs(t.det()) > EPSILON );
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".is_regular()"), Transform_ref, "Transform_is_regular");
    v_util_function_dict_set(q(".is_regular()"), Transform,     "Transform_is_regular");
}

//---------------------------------------------------------------------
Transform_is_affine: (t: &Transform) -> bool
{
    if (!t.norm())  v_return(false);

    t = t[0];

    v_return( abs(t[6]) <= EPSILON  &&
              abs(t[7]) <= EPSILON  &&
              abs(t[8]) >  EPSILON );
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".is_regular()"), Transform_ref, "Transform_is_regular");
    v_util_function_dict_set(q(".is_regular()"), Transform,     "Transform_is_regular");
    v_util_function_dict_set(q(".is_affine()"),  Transform_ref, "Transform_is_affine");
    v_util_function_dict_set(q(".is_affine()"),  Transform,     "Transform_is_affine");
}

//---------------------------------------------------------------------
Transform_op_infix_eq: (a: &Transform, b: &Transform) -> bool
{
    if (!(a.norm()  &&  b.norm()))  v_return(false);

    v_return(seq_equal(a[0], b[0], 9));
}

Transform_op_infix_ne: (a: &Transform, b: &Transform) -> bool
{
    v_return(!Transform_op_infix_eq(a, b));
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_eq"), Transform_ref, "Transform_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Transform_ref, "Transform_op_infix_ne");
    v_util_function_dict_set(q("op_infix_eq"), Transform,     "Transform_op_infix_eq");
    v_util_function_dict_set(q("op_infix_ne"), Transform,     "Transform_op_infix_ne");
}

//---------------------------------------------------------------------
Transform_op_postfix_call_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                      self: v_ast_base_ptr,
                                      args: v_ast_expr_list_ptr,
                                      t0: v_type_ptr, v0: LLVMValueRef
                                     ) -> void
{
    arg = v_list_get_item(args, 0);

    tt = v_get_result_type();

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((arg: v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    q = v_quark_from_string(".transform()");

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    ok = v_util_lookup_function_dict(vis, q, t1, void_fun, void_aux, ft, fv);
    //- assert(ok);

    intrinsic_t = (vis: voidc_visitor_ptr, aux: *void,
                   self: v_ast_base_ptr,
                   args: v_ast_expr_list_ptr,
                   t0: v_type_ptr, v0: LLVMValueRef,
                   t1: v_type_ptr, v1: LLVMValueRef
                  ) -> void;

    if (fun = (void_fun: *intrinsic_t))
    {
        v_set_result_type(tt);

        fun(vis, void_aux, self, args, t1, v1, t0, v0);         //- Sic!!!
    }
    else
    {
        val: &LLVMValueRef[2] := v_undef();

        fpar = v_type_function_get_param_types(ft);

        v_set_result_type(fpar[0]);

        v_adopt_result(t1, v1);                         //- 1 !!!

        val[0] := v_get_result_value();

        v_set_result_type(fpar[1]);

        v_adopt_result(t0, v0);                         //- 0 !!!

        val[1] := v_get_result_value();

        ft_ = v_type_get_llvm_type(ft);

        builder = v_target_get_builder();

        vr = LLVMBuildCall2(builder, ft_, fv, &val[0], 2, "");

        v_set_result_type(tt);

        v_adopt_result(v_type_function_get_return_type(ft), vr);
    }
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_postfix_call"), Transform_ref, "Transform.op_postfix_call_intrinsic");
    v_util_function_dict_set(q("op_postfix_call"), Transform,     "Transform.op_postfix_call_intrinsic");

    v_add_intrinsic("Transform.op_postfix_call_intrinsic", Transform_op_postfix_call_intrinsic, 0);
}

//---------------------------------------------------------------------
Vector_transform: (v: &Vector, t: &Transform) -> Vector
{
    t = t[0];

    x = t[0]*v.x + t[1]*v.y + t[2];
    y = t[3]*v.x + t[4]*v.y + t[5];
    w = t[6]*v.x + t[7]*v.y + t[8];

    v_return({ x/w, y/w });
}

Point_transform: (p: &Point, t: &Transform) -> Point
{
    t = t[0];

    x = t[0]*p.x + t[1]*p.y + t[2]*p.w;
    y = t[3]*p.x + t[4]*p.y + t[5]*p.w;
    w = t[6]*p.x + t[7]*p.y + t[8]*p.w;

    v_return({ x, y, w });
}

Line_transform: (l: &Line, t: &Transform) -> Line
{
    t = t[0];

    cx = det_3({ l.cx, t[3], t[6],
                 l.cy, t[4], t[7],
                 l.cw, t[5], t[8] });

    cy = det_3({ t[0], l.cx, t[6],
                 t[1], l.cy, t[7],
                 t[2], l.cw, t[8] });

    cw = det_3({ t[0], t[3], l.cx,
                 t[1], t[4], l.cy,
                 t[2], t[5], l.cw });

    v_return({ cx, cy, cw });
}

{   Vector_ref = v_reference_type(Vector, 0);
    Point_ref  = v_reference_type(Point,  0);
    Line_ref   = v_reference_type(Line,   0);

    q = v_quark_from_string(".transform()");

    v_util_function_dict_set(q, Vector,     "Vector_transform");
    v_util_function_dict_set(q, Vector_ref, "Vector_transform");
    v_util_function_dict_set(q, Point,      "Point_transform");
    v_util_function_dict_set(q, Point_ref,  "Point_transform");
    v_util_function_dict_set(q, Line,       "Line_transform");
    v_util_function_dict_set(q, Line_ref,   "Line_transform");
}

//---------------------------------------------------------------------
Transform_op_infix_add: (t: &Transform, v: &Vector) -> Transform
{
    t = t[0];

    xx = t[0] + v.x*t[6];
    xy = t[1] + v.x*t[7];
    xw = t[2] + v.x*t[8];

    yx = t[3] + v.y*t[6];
    yy = t[4] + v.y*t[7];
    yw = t[5] + v.y*t[8];

    wx = t[6];
    wy = t[7];
    ww = t[8];

    v_return({{ xx, xy, xw,
                yx, yy, yw,
                wx, wy, ww }});
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_add"), Transform_ref, "Transform_op_infix_add");
    v_util_function_dict_set(q("op_infix_add"), Transform,     "Transform_op_infix_add");
}

//---------------------------------------------------------------------
Transform_op_infix_mul: (a: &Transform, b: &Transform) -> Transform
{
    a = a[0];
    b = b[0];

    xx = a[0]*b[0] + a[1]*b[3] + a[2]*b[6];
    xy = a[0]*b[1] + a[1]*b[4] + a[2]*b[7];
    xw = a[0]*b[2] + a[1]*b[5] + a[2]*b[8];

    yx = a[3]*b[0] + a[4]*b[3] + a[5]*b[6];
    yy = a[3]*b[1] + a[4]*b[4] + a[5]*b[7];
    yw = a[3]*b[2] + a[4]*b[5] + a[5]*b[8];

    wx = a[6]*b[0] + a[7]*b[3] + a[8]*b[6];
    wy = a[6]*b[1] + a[7]*b[4] + a[8]*b[7];
    ww = a[6]*b[2] + a[7]*b[5] + a[8]*b[8];

    v_return({{ xx, xy, xw,
                yx, yy, yw,
                wx, wy, ww }});
}

Transform_op_infix_mul_right: (k: double, t: &Transform) -> Transform
{
    t = t[0];

    xx = k*t[0];
    xy = k*t[1];
    xw = k*t[2];

    yx = k*t[3];
    yy = k*t[4];
    yw = k*t[5];

    wx =   t[6];
    wy =   t[7];
    ww =   t[8];

    v_return({{ xx, xy, xw,
                yx, yy, yw,
                wx, wy, ww }});
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_mul"),       Transform_ref, "Transform_op_infix_mul");
    v_util_function_dict_set(q("op_infix_mul"),       Transform,     "Transform_op_infix_mul");
    v_util_function_dict_set(q("op_infix_mul.right"), Transform_ref, "Transform_op_infix_mul_right");
    v_util_function_dict_set(q("op_infix_mul.right"), Transform,     "Transform_op_infix_mul_right");
}

//---------------------------------------------------------------------
Transform_op_prefix_tilda: (t: &Transform) -> Transform
{
    t = t[0];

    xx = t[4]*t[8] - t[5]*t[7];
    xy = t[2]*t[7] - t[1]*t[8];
    xw = t[1]*t[5] - t[2]*t[4];

    yx = t[5]*t[6] - t[3]*t[8];
    yy = t[0]*t[8] - t[2]*t[6];
    yw = t[2]*t[3] - t[0]*t[5];

    wx = t[3]*t[7] - t[4]*t[6];
    wy = t[1]*t[6] - t[0]*t[7];
    ww = t[0]*t[4] - t[1]*t[3];

    r: &Transform := {{ xx,xy,xw, yx,yy,yw, wx,wy,ww }};

    if (r.det() < 0)
    {
        r = r[0];

        for (i: &int := 0; i < 9; ++i)  r[i] := -r[i];
    }

    v_return(r);
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_prefix_tilda"), Transform_ref, "Transform_op_prefix_tilda");
    v_util_function_dict_set(q("op_prefix_tilda"), Transform,     "Transform_op_prefix_tilda");
}

//---------------------------------------------------------------------
Transform_op_infix_div: (a: &Transform, b: &Transform) -> Transform
{
    v_return(a * (~b));
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q("op_infix_div"), Transform_ref, "Transform_op_infix_div");
    v_util_function_dict_set(q("op_infix_div"), Transform,     "Transform_op_infix_div");
}

//---------------------------------------------------------------------
Transform_scaled: (t: &Transform, k: double) -> Transform
{
    v_return(k * t);
}

Transform_shifted: (t: &Transform, v: &Vector) -> Transform
{
    v_return(t + v);
}

Transform_rotated: (t: &Transform, d: double) -> Transform
{
    a = d/180*M_PI;

    sa = sin(a);
    ca = cos(a);

    r: Transform = {{  ca, -sa,  0,
                       sa,  ca,  0,
                        0,   0,  1  }};

    v_return(r * t);
}

{   Transform_ref = v_reference_type(Transform, 0);

    q = v_quark_from_string;

    v_util_function_dict_set(q(".scaled()"),  Transform_ref, "Transform_scaled");
    v_util_function_dict_set(q(".scaled()"),  Transform,     "Transform_scaled");
    v_util_function_dict_set(q(".shifted()"), Transform_ref, "Transform_shifted");
    v_util_function_dict_set(q(".shifted()"), Transform,     "Transform_shifted");
    v_util_function_dict_set(q(".rotated()"), Transform_ref, "Transform_rotated");
    v_util_function_dict_set(q(".rotated()"), Transform,     "Transform_rotated");
}

//---------------------------------------------------------------------
_map4_util: (o1: &Point, o2: &Point, o3: &Point, o4: &Point) -> Transform
{
    o1.norm();
    o2.norm();
    o3.norm();
    o4.norm();

    a1 = det_3({ o4.x, o2.x, o3.x,
                 o4.y, o2.y, o3.y,
                 o4.w, o2.w, o3.w });

    a2 = det_3({ o1.x, o4.x, o3.x,
                 o1.y, o4.y, o3.y,
                 o1.w, o4.w, o3.w });

    a3 = det_3({ o1.x, o2.x, o4.x,
                 o1.y, o2.y, o4.y,
                 o1.w, o2.w, o4.w });

    v_return( {{ o1.x*a1, o2.x*a2, o3.x*a3,
                 o1.y*a1, o2.y*a2, o3.y*a3,
                 o1.w*a1, o2.w*a2, o3.w*a3 }} );
}

Transform_map4: (i1: &Point, i2: &Point, i3: &Point, i4: &Point,
                 o1: &Point, o2: &Point, o3: &Point, o4: &Point
                ) -> Transform
{
    t1 = _map4_util(i1, i2, i3, i4);
    t2 = _map4_util(o1, o2, o3, o4);

    v_return(t2 / t1);
}

Transform_map3: (i1: &Point, i2: &Point, i3: &Point,
                 o1: &Point, o2: &Point, o3: &Point
                ) -> Transform
{
    i4 = i3 + (i2 - i1);
    o4 = o3 + (o2 - o1);

    v_return( Transform_map4(i1, i2, i3, i4,  o1, o2, o3, o4) );
}

Transform_map2: (i1: &Point, i2: &Point,
                 o1: &Point, o2: &Point
                ) -> Transform
{
    v = i2 - i1;    v: Vector = { -v.y, v.x };

    i3 = i1 + v;

    v = o2 - o1;    v: Vector = { -v.y, v.x };

    o3 = o1 + v;

    v_return( Transform_map3(i1, i2, i3,  o1, o2, o3) );
}

Transform_map2_mirror: (i1: &Point, i2: &Point,
                        o1: &Point, o2: &Point
                       ) -> Transform
{
    v = i2 - i1;    v: Vector = { -v.y, v.x };

    i3 = i1 + v;

    v = o2 - o1;    v: Vector = { v.y, -v.x };

    o3 = o1 + v;

    v_return( Transform_map3(i1, i2, i3,  o1, o2, o3) );
}

//---------------------------------------------------------------------
Transform_identity: Transform = {{ 1, 0, 0,  0, 1, 0,  0, 0, 1 }};
Transform_flip_x:   Transform = {{-1, 0, 0,  0, 1, 0,  0, 0, 1 }};
Transform_flip_y:   Transform = {{ 1, 0, 0,  0,-1, 0,  0, 0, 1 }};





//=====================================================================
//{ v_debug_print_module(2); }
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    v: &Vector := {1, 2};

    sstr << v + 2*v;

    printf("s: %s\n", v_std_string_get(sstr));


    v_std_string_set(sstr, "");

    u = Point_unit_x - Point_unit_y;

    p = Point_zero + u/3;

    sstr << p;

    printf("p: %s\n", v_std_string_get(sstr));


    v_std_string_set(sstr, "");

    p_inf_x = Line_abscissa & Line_infinity;

    l = Point_unit_y & p_inf_x;

    sstr << l;

    printf("l: %s\n", v_std_string_get(sstr));


    //-----------------------------------------------------------------
    t: &Transform := {{ 0, -1, 0,  1, 0, 0,  0, 0, 1 }};

    v = t(Vector_unit_x);
//  v = Vector_unit_x.transform(t);

    v_std_string_set(sstr, "");     sstr << v;

    printf("v: %s\n", v_std_string_get(sstr));

    p = t(Point_unit_x);

    v_std_string_set(sstr, "");     sstr << p;

    printf("p: %s\n", v_std_string_get(sstr));

    l = t(Line_ordinate);

    v_std_string_set(sstr, "");     sstr << l;

    printf("l: %s\n", v_std_string_get(sstr));
}

//---------------------------------------------------------------------
//{ v_debug_print_module(1); }
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    r = Transform_identity.rotated(45);

//  v = r(Vector_unit_x);
    v = r(Vector_unit_y);

    v_std_string_set(sstr, "");     sstr << v;

    printf("v: %s\n", v_std_string_get(sstr));

}


